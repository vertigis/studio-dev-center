"use strict";(globalThis.webpackChunkvertigis_studio_dev_center=globalThis.webpackChunkvertigis_studio_dev_center||[]).push([[4651],{7653:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>a,default:()=>p,frontMatter:()=>i,metadata:()=>l,toc:()=>c});var r=t(4848),o=t(8453),s=t(8774);const i={title:"New Workflow Form Element API",author:"Ian Schmitz",authorTitle:"Software Architect",authorURL:"https://github.com/ianschmitz",authorImageURL:"https://github.com/ianschmitz.png",tags:["workflow"]},a=void 0,l={permalink:"/blog/2021/03/22/new-workflow-element-api",source:"@site/blog/2021-03-22-new-workflow-element-api.mdx",title:"New Workflow Form Element API",description:"Workflow 5.21 includes a new TypeScript form element API that you can use for building custom form elements using the VertiGIS Studio Workflow TypeScript SDK. The existing patterns and APIs you've been using for years to build custom form elements will continue to work, but we encourage you to try the new API when building new form elements.",date:"2021-03-22T00:00:00.000Z",tags:[{label:"workflow",permalink:"/blog/tags/workflow"}],readingTime:9.06,hasTruncateMarker:!0,authors:[{name:"Ian Schmitz",title:"Software Architect",url:"https://github.com/ianschmitz",imageURL:"https://github.com/ianschmitz.png"}],frontMatter:{title:"New Workflow Form Element API",author:"Ian Schmitz",authorTitle:"Software Architect",authorURL:"https://github.com/ianschmitz",authorImageURL:"https://github.com/ianschmitz.png",tags:["workflow"]},unlisted:!1,prevItem:{title:"Mobile Generic Event Listener",permalink:"/blog/2023/03/01/mobile-generic-event-listener"}},d={authorsImageUrls:[void 0]},c=[{value:"New State Management API",id:"new-state-management-api",level:2},{value:"Improved <code>props</code> interface",id:"improved-props-interface",level:3},{value:"<code>setValue()</code> and <code>setProperty()</code>",id:"setvalue-and-setproperty",level:3},{value:"Simplified Element Registration",id:"simplified-element-registration",level:2},{value:"Improved UI Consistency",id:"improved-ui-consistency",level:2},{value:"Summary",id:"summary",level:2},{value:"Simple Use Case",id:"simple-use-case",level:3},{value:"Before",id:"before",level:4},{value:"After",id:"after",level:4},{value:"Advanced Use Case",id:"advanced-use-case",level:3},{value:"Before",id:"before-1",level:4},{value:"After",id:"after-1",level:4}];function m(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h2:"h2",h3:"h3",h4:"h4",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,o.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.p,{children:["Workflow ",(0,r.jsx)(n.code,{children:"5.21"})," includes a new TypeScript form element API that you can use for building custom form elements using the ",(0,r.jsx)(s.A,{to:"/docs/workflow/sdk-web-overview",children:"VertiGIS Studio Workflow TypeScript SDK"}),". The existing patterns and APIs you've been using for years to build custom form elements will continue to work, but we encourage you to try the new API when building new form elements."]}),"\n",(0,r.jsx)(n.admonition,{type:"note",children:(0,r.jsx)(n.p,{children:"To use these new features, you will need the latest version of VertiGIS Studio Workflow, as well as the VertiGIS Studio Workflow SDK."})}),"\n",(0,r.jsx)(n.p,{children:"The new form element API provides a number of new features and benefits:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#new-state-management-api",children:"New state management API"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#simplified-element-registration",children:"Simplified element registration"})}),"\n"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#improved-ui-consistency",children:"Improved UI consistency"})}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"new-state-management-api",children:"New State Management API"}),"\n",(0,r.jsx)(n.p,{children:"We've created a new state management API that improves custom form element development in a number of ways. Let's take a look in-depth at what's changed."}),"\n",(0,r.jsxs)(n.h3,{id:"improved-props-interface",children:["Improved ",(0,r.jsx)(n.code,{children:"props"})," interface"]}),"\n",(0,r.jsxs)(n.p,{children:["We now provide an easy way to extend the props interface with additional public properties for your element. We've also flattened the element's properties from ",(0,r.jsx)(n.code,{children:"props.element"})," onto the root of the ",(0,r.jsx)(n.code,{children:"props"})," object and have removed unused properties that were used internally in the product but didn't make sense for most custom form elements:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-diff",children:"- import { CustomFormElementProps } from \"@geocortex/workflow/runtime/app/RegisterCustomFormElementBase\";\n+ import { FormElementProps } from \"@geocortex/workflow/runtime\";\n\n\n// The generic type argument provided to `FormElementProps`\n// allows you to specify the type of `value`.\n// This will strongly type `props.value` and `props.setValue()`.\n// You can now add additional properties to your element's\n// props interface. Previously there wasn't a great pattern\n// to declare additional properties for an element.\n+ interface DemoElementProps extends FormElementProps<number> {\n+    foo: string;\n+ }\n\n\n- function DemoElement(props: CustomFormElementProps) {\n+ function DemoElement(props: DemoElementProps) {\n    // Get the current `value`. Previously `value` wouldn't be\n    // strongly typed. Here we've typed as `number` as declared\n    // in our interface above.\n-   const currentValue = props.element.value;\n+   const currentValue = props.value;\n\n\n    // Get a custom `foo` property used by my element.\n+   const currentFoo = props.foo;\n\n\n    // ...\n}\n"})}),"\n",(0,r.jsxs)(n.h3,{id:"setvalue-and-setproperty",children:[(0,r.jsx)(n.code,{children:"setValue()"})," and ",(0,r.jsx)(n.code,{children:"setProperty()"})]}),"\n",(0,r.jsx)(n.p,{children:"These new APIs are included in the props interface and help to improve developer experience and ensure form consistency of both the UI presentation, but also the underlying element state."}),"\n",(0,r.jsxs)(n.p,{children:["We've added the ",(0,r.jsx)(n.code,{children:"setProperty()"})," API which is used to update properties of your element, such as additional public properties that you've added to your element by extending the ",(0,r.jsx)(n.code,{children:"FormElementProps"})," interface."]}),"\n",(0,r.jsxs)(n.p,{children:["We've also added ",(0,r.jsx)(n.code,{children:"setValue()"}),". ",(0,r.jsx)(n.code,{children:"setValue(value)"})," is equivalent to calling ",(0,r.jsx)(n.code,{children:'setProperty("value", value)'}),". Using the previous API, developers had to remember to raise the ",(0,r.jsx)(n.code,{children:"changed"})," event when updating the ",(0,r.jsx)(n.code,{children:"value"})," property on their element. This was necessary so that workflow authors could run sub-workflows on the ",(0,r.jsx)(n.code,{children:"change"})," event of the element. This is no longer needed as the ",(0,r.jsx)(n.code,{children:"setValue()"})," API will automatically raise the ",(0,r.jsx)(n.code,{children:"changed"})," event for you."]}),"\n",(0,r.jsxs)(n.p,{children:["Additionally, the previous patterns didn't guarantee that the form would re-render after updating the properties of your element and could result in some challenging UI and data consistency issues. By using the ",(0,r.jsx)(n.code,{children:"setProperty()"})," and ",(0,r.jsx)(n.code,{children:"setValue()"})," APIs, your form will automatically be re-rendered to ensure that the UI shows the most up-to-date state at all times."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-diff",children:'// Get the current `value`.\n- const currentValue = props.element.value;\n+ const currentValue = props.value;\n\n\n// Update the element\'s value.\n- props.element.value = value;\n- props.raiseEvent("changed", value);\n+ props.setValue(value);\n\n\n// Get a custom `foo` property used by my element.\n- const currentFoo = (props.element as any).foo;\n+ const currentFoo = props.foo;\n\n\n// Set the element\'s `foo` property.\n- (props.element as any).foo = foo;\n+ props.setProperty("foo", foo);\n'})}),"\n",(0,r.jsx)(n.h2,{id:"simplified-element-registration",children:"Simplified Element Registration"}),"\n",(0,r.jsx)(n.p,{children:"To register your custom form elements using the previous API, you would need to create a Workflow activity that registers your element:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:'export class RegisterDemoElement extends RegisterCustomFormElementBase {\n    execute(): void {\n        // Where `DemoElement` refers to a React component.\n        this.register("Demo", DemoElement);\n    }\n}\n'})}),"\n",(0,r.jsxs)(n.p,{children:["This added some extra boilerplate that we felt was unnecessary. More importantly it required the workflow author to run this element registration activity ",(0,r.jsx)(n.em,{children:"prior"})," to running the ",(0,r.jsx)(n.em,{children:"Display Form"})," activity that used the custom element. This was an awkward step that Workflow authors had to remember to do for their forms to render correctly."]}),"\n",(0,r.jsxs)(n.p,{children:["When registering your element using the new API and the latest version of the Workflow SDK, it is no longer necessary to run the activity prior to ",(0,r.jsx)(n.em,{children:"Display Form"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:'const DemoElementRegistration: FormElementRegistration<DemoElementProps> =\n    {\n        component: DemoElement,\n        id: "Demo",\n    };\n\nexport default DemoElementRegistration;\n'})}),"\n",(0,r.jsx)(n.h2,{id:"improved-ui-consistency",children:"Improved UI Consistency"}),"\n",(0,r.jsxs)(n.p,{children:["The new ",(0,r.jsx)(n.code,{children:"setProperty()"})," and ",(0,r.jsx)(n.code,{children:"setValue()"})," APIs make it much easier to develop Workflow elements using the common patterns developers are familiar with when building React components. Let's look at a simple example of a text input element built using the previous API:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-tsx",children:"function Text(props: CustomFormElementProps) {\n    return (\n        <input\n            // When the text input changes, update the element's `value`.\n            onChange={(event) =>\n                (props.element.value = event.currentTarget.value)\n            }\n            // Show the element `value `in the text input.\n            value={props.element.value}\n        />\n    );\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"There are a few gotchas here that are likely not obvious at first glance:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["We forgot to call ",(0,r.jsx)(n.code,{children:'props.raiseEvent("changed", value)'}),". If the workflow author tried to run a sub-workflow on the change event of your element, it would never run."]}),"\n",(0,r.jsxs)(n.li,{children:["The re-rendering of the element wasn't deterministic previously. Even if we updated ",(0,r.jsx)(n.code,{children:"props.element.value"})," ",(0,r.jsx)(n.em,{children:"and"})," invoked ",(0,r.jsx)(n.code,{children:'props.raiseEvent("changed", value)'}),", there was no guarantee that this element would re-render immediately. In that case the UI wouldn't show the updated value, and would be out-of-sync with the underlying state of the element."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"value"})," will be ",(0,r.jsx)(n.code,{children:"undefined"})," during the initial render, until the ",(0,r.jsx)(n.code,{children:"onChange"})," fires for the first time. There are ways to work around this such as running a sub-workflow on the ",(0,r.jsx)(n.code,{children:"load"})," event to set the element's value, however this makes development awkward."]}),"\n",(0,r.jsxs)(n.li,{children:["Other parts of the system could update the element's ",(0,r.jsx)(n.code,{children:"value"})," to a type that the element doesn't expect. For example, instead of ",(0,r.jsx)(n.code,{children:"value"})," being a ",(0,r.jsx)(n.code,{children:"string"})," like we expect, the workflow author could accidentally set the value to an ",(0,r.jsx)(n.code,{children:"object"})," using the ",(0,r.jsx)(n.em,{children:"Set Form Element Property"})," activity."]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"It was possible to overcome these gotchas, but it required additional logic that often wasn't immediately obvious. We've had to overcome these same challenges when writing form elements within Workflow itself."}),"\n",(0,r.jsx)(n.p,{children:"So how would we build this element using the new APIs and avoid the gotchas described above? Let's take a look:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-tsx",children:'interface TextProps extends FormElementProps<string> {}\n\nfunction Text(props: TextProps) {\n    return (\n        <input\n            // 1. `setValue()` automatically raises the `changed`\n            // event for you.\n            onChange={(event) =>\n                props.setValue(event.currentTarget.value)\n            }\n            // 2. The component will be re-rendered immediately by\n            // using `setValue()`, ensuring that your UI and element\n            // state are consistent.\n            value={props.value}\n        />\n    );\n}\n\nconst TextElementRegistration: FormElementRegistration<TextProps> = {\n    component: Text,\n    id: "Text",\n    // 3. We can provide a default value, avoiding the initial\n    // `undefined` value.\n    getInitialProperties: () => ({ value: "" }),\n    // 4. We can ensure data consistency by sanitizing changes\n    // to our element\'s properties.\n    onPropertyChange: ({ properties, property }) => {\n        if (property === "value") {\n            const value = properties[property];\n\n            if (typeof value !== "string") {\n                throw new Error("Unexpected type");\n            }\n        }\n    },\n};\n'})}),"\n",(0,r.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,r.jsx)(n.p,{children:"So what does all of this mean in practice? Below we'll compare elements built using the new and old APIs."}),"\n",(0,r.jsx)(n.h3,{id:"simple-use-case",children:"Simple Use Case"}),"\n",(0,r.jsx)(n.p,{children:"Here's a simple text input element:"}),"\n",(0,r.jsx)(n.h4,{id:"before",children:"Before"}),"\n",(0,r.jsxs)(n.p,{children:["For the sake of brevity, we've excluded the additional logic that would be needed to overcome the gotchas ",(0,r.jsx)(n.a,{href:"#improved-ui-consistency",children:"described above"}),"."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-tsx",children:'import * as React from "react";\nimport { CustomFormElementProps } from "@geocortex/workflow/runtime/app/RegisterCustomFormElementBase";\n\nclass Text extends React.Component<CustomFormElementProps> {\n    render(props) {\n        return (\n            <input\n                value={props.element.value}\n                onChange={(event) => {\n                    this.props.element.value = value;\n                    this.props.raiseEvent("changed", value);\n                }}\n            />\n        );\n    }\n}\n\n/**\n * @displayName Text\n * @category Custom Activities\n * @description Registers the text input element for use in Display Form.\n */\nexport class RegisterTextElement extends RegisterCustomFormElementBase {\n    execute(): void {\n        this.register("Text", Text);\n    }\n}\n'})}),"\n",(0,r.jsx)(n.h4,{id:"after",children:"After"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-tsx",children:'import {\n    FormElementProps,\n    FormElementRegistration,\n} from "@geocortex/workflow/runtime";\n\ninterface TextProps extends FormElementProps<string> {}\n\n/**\n * @displayName Text\n * @category Custom Activities\n * @description Displays a text input element.\n */\nfunction Text(props: TextProps) {\n    return (\n        <input\n            value={props.value}\n            onChange={(event) =>\n                props.setValue(event.currentTarget.value)\n            }\n        />\n    );\n}\n\nconst TextElementRegistration: FormElementRegistration<TextProps> = {\n    component: Text,\n    id: "Text",\n    getInitialProperties: () => ({\n        value: "Hello World",\n    }),\n};\n'})}),"\n",(0,r.jsxs)(n.p,{children:["Notice that updating the ",(0,r.jsx)(n.code,{children:"value"})," for the element has been simplified by using the ",(0,r.jsx)(n.code,{children:"setValue()"})," API. We're also now able to provide a default ",(0,r.jsx)(n.code,{children:"value"})," of ",(0,r.jsx)(n.code,{children:'"Hello World"'})," using ",(0,r.jsx)(n.code,{children:"getInitialProperties"}),"."]}),"\n",(0,r.jsx)(n.h3,{id:"advanced-use-case",children:"Advanced Use Case"}),"\n",(0,r.jsx)(n.p,{children:"Here's a more advanced element that displays a range slider with configurable min, max, and step settings:"}),"\n",(0,r.jsx)(n.h4,{id:"before-1",children:"Before"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-tsx",children:'import * as React from "react";\nimport {\n    CustomFormElementProps,\n    RegisterCustomFormElementBase,\n} from "@geocortex/workflow/runtime/app/RegisterCustomFormElementBase";\n\nclass RangeSlider extends React.Component<CustomFormElementProps> {\n    render() {\n        const { element, raiseEvent } = this.props;\n\n        return (\n            <div>\n                <input\n                    max={100}\n                    min={0}\n                    // Even though we\'re updating the element value, until\n                    // the element is re-rendered the UI won\'t update.\n                    onChange={(event) => {\n                        const value =\n                            event.currentTarget.valueAsNumber;\n                        element.value = value;\n                        raiseEvent("changed", value);\n                    }}\n                    step={5}\n                    type="range"\n                    // There\'s no way to guarantee that `value` is always a\n                    // `number`. A workflow could set the `value` to an\n                    // unexpected type such as by using the\n                    // `Set Form Element Property` activity.\n                    value={element.value as number}\n                />\n                {/* \n                    The element wasn\'t guaranteed to re-render, \n                    so this UI may not update immediately.\n                    `element.value` will be `undefined` initially\n                    until set the first time.\n                */}\n                <span>{element.value}</span>\n            </div>\n        );\n    }\n}\n\n/**\n * @displayName Register RangeSlider Form Element\n * @description Displays a number range slider.\n * @param props The props that will be provided by the Workflow runtime.\n */\nexport class RegisterRangeSliderElement extends RegisterCustomFormElementBase {\n    execute(): void {\n        this.register("RangeSlider", RangeSlider);\n    }\n}\n'})}),"\n",(0,r.jsx)(n.h4,{id:"after-1",children:"After"}),"\n",(0,r.jsxs)(n.p,{children:["Here's the same element but also including configurable ",(0,r.jsx)(n.code,{children:"max"}),", ",(0,r.jsx)(n.code,{children:"min"}),", and ",(0,r.jsx)(n.code,{children:"step"})," properties."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-tsx",children:'import * as React from "react";\nimport {\n    FormElementProps,\n    FormElementRegistration,\n} from "@geocortex/workflow/runtime";\n\ninterface RangeSliderProps extends FormElementProps<number> {\n    max: number;\n    min: number;\n    step: number;\n}\n\n/**\n * @displayName Range Slider\n * @description Displays a number range slider.\n * @param props The props that will be provided by the Workflow runtime.\n */\nfunction RangeSlider(props: RangeSliderProps): React.ReactElement {\n    const { max, min, setValue, step, value } = props;\n    return (\n        <div>\n            <input\n                max={max}\n                min={min}\n                onChange={(event) =>\n                    setValue(event.currentTarget.valueAsNumber)\n                }\n                step={step}\n                type="range"\n                value={value}\n            />\n            <span>{value}</span>\n        </div>\n    );\n}\n\nconst RangeSliderElementRegistration: FormElementRegistration<RangeSliderProps> =\n    {\n        component: RangeSlider,\n        getInitialProperties: () => ({\n            max: 100,\n            min: 0,\n            step: 5,\n            value: 50,\n        }),\n        id: "RangeSlider",\n        onPropertyChange: ({ properties, property }) => {\n            if (\n                property === "max" ||\n                property === "min" ||\n                property === "step" ||\n                property === "value"\n            ) {\n                const value = properties[property];\n\n                // Ensure we always have the type we expect assigned to the element\n                // properties.\n                if (\n                    typeof value !== "number" ||\n                    Number.isNaN(value)\n                ) {\n                    throw new Error("Unexpected type");\n                }\n            }\n        },\n    };\n\nexport default RangeSliderElementRegistration;\n'})})]})}function p(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(m,{...e})}):m(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>a});var r=t(6540);const o={},s=r.createContext(o);function i(e){const n=r.useContext(s);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:i(e.components),r.createElement(s.Provider,{value:n},e.children)}}}]);