"use strict";(globalThis.webpackChunkvertigis_studio_dev_center=globalThis.webpackChunkvertigis_studio_dev_center||[]).push([[5894],{6042:e=>{e.exports=JSON.parse('{"blogPosts":[{"id":"/2024/08/22/mobile-maui-announcement","metadata":{"permalink":"/blog/2024/08/22/mobile-maui-announcement","source":"@site/blog/2024-08-22-mobile-maui-announcement.mdx","title":"VertiGIS Mobile Now Supports ArcGIS Maps SDK 200.x","description":"A new version of VertiGIS Mobile, based on Esri\'s new 200.x ArcGIS Maps SDK for .NET, is now available as a beta.","date":"2024-08-22T00:00:00.000Z","tags":[{"label":"mobile","permalink":"/blog/tags/mobile"}],"readingTime":0.915,"hasTruncateMarker":true,"authors":[{"name":"Felicity Rhone","title":"Software Developer","url":"https://github.com/Felicity-R","imageURL":"https://github.com/felicity-r.png"}],"frontMatter":{"title":"VertiGIS Mobile Now Supports ArcGIS Maps SDK 200.x","author":"Felicity Rhone","authorTitle":"Software Developer","authorURL":"https://github.com/Felicity-R","authorImageURL":"https://github.com/felicity-r.png","tags":["mobile"]},"unlisted":false,"nextItem":{"title":"Creating Custom Bands with the Inline SDK","permalink":"/blog/2023/06/20/inline-sdk"}},"content":"import Link from \\"@docusaurus/Link\\";\\n\\nA new version of VertiGIS Mobile, based on Esri\'s new 200.x ArcGIS Maps SDK for .NET, is now available as a beta.\\n\\n\x3c!--truncate--\x3e\\n\\nWith the new SDK, Esri dropped support for Xamarin Forms in favor of .NET MAUI. Therefore, upgrading to the 200.x SDK also necessitated updating our version of .NET and migrating VertiGIS Mobile from a Xamarin Forms-based solution to a MAUI-based solution.\\n\\nFor a large project like Mobile, which includes dozens of custom controls for each of our supported platforms (iOS, Android and Windows), this turned out to be a complicated and time-consuming endeavor. We had to contend not only with deprecations and breaking changes in the Esri SDK, MAUI, and other third-party libraries, but also with unexpected issues in MAUI, as it was in its early days itself when we started our upgrade and went through a few growing pains.\\n\\nWe are glad to finally be able to present the result of our hard work to the public. See [our Community post here](https://support.vertigis.com/hc/en-us/community/posts/20063879496594-Open-Beta-for-NET-200-x-MAUI-release-of-VertiGIS-Studio-Go) for more information on how to access the beta and to provide feedback."},{"id":"/2023/06/20/inline-sdk","metadata":{"permalink":"/blog/2023/06/20/inline-sdk","source":"@site/blog/2023-06-20-inline-sdk.mdx","title":"Creating Custom Bands with the Inline SDK","description":"With VertiGIS Inline 2.3 and later, users now have the ability to create their own custom bands that run right in Inline using the VertiGIS Inline SDK. These custom bands are made with React and TypeScript, giving authors total control over what the band can do. Today, we will run through the steps to build, deploy and use a custom band in an Inline view.","date":"2023-06-20T00:00:00.000Z","tags":[{"label":"inline","permalink":"/blog/tags/inline"},{"label":"web","permalink":"/blog/tags/web"}],"readingTime":19.685,"hasTruncateMarker":true,"authors":[{"name":"Michael Kowal","title":"Software Developer","url":"https://github.com/MichaelKowal","imageURL":"https://github.com/MichaelKowal.png"}],"frontMatter":{"title":"Creating Custom Bands with the Inline SDK","author":"Michael Kowal","authorTitle":"Software Developer","authorURL":"https://github.com/MichaelKowal","authorImageURL":"https://github.com/MichaelKowal.png","tags":["inline","web"]},"unlisted":false,"prevItem":{"title":"VertiGIS Mobile Now Supports ArcGIS Maps SDK 200.x","permalink":"/blog/2024/08/22/mobile-maui-announcement"},"nextItem":{"title":"Mobile Generic Event Listener","permalink":"/blog/2023/03/01/mobile-generic-event-listener"}},"content":"import Link from \\"@docusaurus/Link\\";\\nimport useBaseUrl from \\"@docusaurus/useBaseUrl\\";\\n\\nWith VertiGIS Inline `2.3` and later, users now have the ability to create their own custom bands that run right in Inline using the VertiGIS Inline SDK. These custom bands are made with React and TypeScript, giving authors total control over what the band can do. Today, we will run through the steps to build, deploy and use a custom band in an Inline view.\\n\\n\x3c!--truncate--\x3e\\n\\n:::note\\nTo use these new features, you will need the latest versions of VertiGIS Inline, VertiGIS Studio Web, and the VertiGIS Inline SDK.\\n:::\\n\\n## Getting Started\\n\\nYou will need a few tools to build a custom band:\\n\\n-   [Download and install Node.js](https://nodejs.org/en)\\n-   [Download and install Visual Studio Code](https://code.visualstudio.com/download)\\n\\nOnce you are set up with those you can create a folder with everything you need to build a custom band. With the terminal of your choice, create instance of inline sdk with\\n\\n```\\nnpx @vertigis/inline-sdk create <my-project>\\n```\\n\\nOpen the folder with the name you supplied in VS Code. You should see a number of files already there.\\n\\n## Exploring the SDK\\n\\nThere are a few key parts of the SDK that you can use to build your own custom band.\\n\\n### Registry Service\\n\\nCustom bands are registered in Inline using a custom VertiGIS Web service. This service is found in `src/services/CustomBandRegistry/CustomBandRegistry.ts`. This file loads any available custom bands and registers them with Inline when it is added to an app. It can register any number of custom bands at the same time.\\n\\n:::danger Warning\\nModifying this service is not recommended. It can result in unexpected behavior including causing your app to crash. Do so at your own risk.\\n:::\\n\\n### Types\\n\\nIn the `src/definitions/inline.d.ts` file you can find all of the Inline types that you can use to create your custom band. There are comments provided in this file to describe the uses of these types.\\n\\n### Sample Band\\n\\nThe Inline SDK comes preinstalled with a sample band that you can use for reference. In your SDK navigate to `src/bands/SampleBand`. In here you will find 4 files.\\n\\n-   `Band.css` contains the styles that are applied to the chart.\\n-   `Band.tsx` contains the React code that is run in Inline.\\n-   `designer.ts` describes the settings that are available when configuring a custom band in the Inline Designer.\\n-   `index.ts` combines it all together to be properly registered.\\n\\n## Creating a new band\\n\\nThe band we will be creating today will be able to display a video and seek to any point in the video based on the location of the crosshair on the map and on other inline charts.\\n\\nTo create a new band run\\n\\n```\\nnpx @vertigis/inline-sdk generate VideoBand\\n```\\n\\n:::info Important\\nThe `generate` command must be run from within the custom band project folder.\\n:::\\n\\n### Add settings for the Inline Designer\\n\\nThe `designer.ts` file provides the Inline designer with a settings schema to display configurable settings for a custom band. These settings can be any combination of:\\n\\n-   input\\n-   checkbox\\n-   radio\\n-   dropdown\\n\\nThe Sample Band has some examples of how to use these settings. The `src/bands/VideoBand/designer.ts` file will have a small function ready to go.\\n\\n```ts title=\\"src/bands/VideoBand/designer.ts\\"\\nimport { InlineDesignerConfig } from \\"inline\\";\\n\\nexport const getDesignerConfig = (): InlineDesignerConfig => {\\n    const config: InlineDesignerConfig = [\\n        {\\n            title: \\"Video Band Settings\\",\\n            fields: [],\\n        },\\n    ];\\n\\n    return config;\\n};\\n```\\n\\nThe `InlineDesignerConfig` is a list of settings sections. Each section has a name and list of fields that can be configured by users in the Inline designer.\\n\\nNext, add an input field for the video URL.\\n\\n```ts title=\\"src/bands/VideoBand/designer.ts\\"\\n// highlight-next-line\\nimport { InlineDesignerConfig, InputDesignerConfig } from \\"inline\\";\\n\\nexport const getDesignerConfig = () => {\\n    const config: InlineDesignerConfig = [\\n        {\\n            title: \\"Video Band Settings\\",\\n            fields: [],\\n        },\\n    ];\\n\\n    // highlight-start\\n    const urlField: InputDesignerConfig = {\\n        id: \\"url\\",\\n        type: \\"input\\",\\n        default: \\"\\",\\n        label: \\"Video URL\\",\\n        helpText:\\n            \\"The URL of the video. This must be a valid URL to a video file.\\",\\n    };\\n\\n    config[0].fields.push(urlField);\\n    // highlight-end\\n\\n    return config;\\n};\\n```\\n\\nThis pattern can be repeated to create any other settings that are necessary for the band.\\n\\n### Creating a Video Player React Hook\\n\\nWithout a video player, this band will not do much. Let\'s create one using a custom React Hook.\\n\\nCreate a new file the the `VideoBand` folder called `useVideoPlayer.ts`. In this file we will include all the tools we need to create an interactive video player in a custom band.\\n\\nSet up the hook as a function that takes a single parameter, `videoElement`. This is a reference to a video HTML element.\\n\\n```ts title=\\"src/bands/VideoBand/useVideoPlayer.ts\\"\\nconst useVideoPlayer = (\\n    videoElement: React.MutableRefObject<HTMLVideoElement>\\n) => {};\\n\\nexport default useVideoPlayer;\\n```\\n\\nAdd some state to track to current status of the player.\\n\\n```ts title=\\"src/bands/VideoBand/useVideoPlayer.ts\\"\\n// highlight-next-line\\nimport { useState } from \\"react\\";\\n\\nconst useVideoPlayer = (\\n    videoElement: React.MutableRefObject<HTMLVideoElement>\\n) => {\\n    // highlight-start\\n    const [playerState, setPlayerState] = useState({\\n        isPlaying: false,\\n        progress: 0,\\n        speed: 1,\\n        isMuted: false,\\n    });\\n    //highlight-end\\n};\\n```\\n\\nAdd a function to toggle the current play/pause state of the video.\\n\\n```ts title=\\"src/bands/VideoBand/useVideoPlayer.ts\\"\\nconst useVideoPlayer = (videoElement: React.MutableRefObject<HTMLVideoElement>) => {\\n    ...\\n    // highlight-start\\n    const togglePlay = () => {\\n        setPlayerState({\\n            ...playerState,\\n            isPlaying: !playerState.isPlaying\\n        });\\n    }\\n    //highlight-end\\n}\\n```\\n\\nAdd a function that updates the progress bar of the video as it is playing. The progress is any value between 0 and 100 and is not directly related to the length of the video.\\n\\n```ts title=\\"src/bands/VideoBand/useVideoPlayer.ts\\"\\nconst useVideoPlayer = (videoElement: React.MutableRefObject<HTMLVideoElement>) => {\\n    ...\\n    // highlight-start\\n    const handleOnTimeUpdate = () => {\\n        const progress = (videoElement.current.currentTime / videoElement.current.duration) * 100;\\n        setPlayerState({\\n            ...playerState,\\n            progress\\n        });\\n    };\\n    //highlight-end\\n}\\n```\\n\\nAdd a function to seek to any point in the video, taking a number that is the percentage of the video length that the video should start playing at.\\n\\n```ts title=\\"src/bands/VideoBand/useVideoPlayer.ts\\"\\nconst useVideoPlayer = (videoElement: React.MutableRefObject<HTMLVideoElement>) => {\\n    ...\\n    // highlight-start\\n    const seekTo = (value: number) => {\\n        if (value >= 0 && value <= 100) {\\n            videoElement.current.currentTime = (videoElement.current.duration / 100) * value;\\n            setPlayerState({\\n                ...playerState,\\n                progress: value\\n            });\\n        }\\n    };\\n    //highlight-end\\n}\\n```\\n\\nAdd functions to change the playback speed of the video and turn the sound on/off.\\n\\n```ts title=\\"src/bands/VideoBand/useVideoPlayer.ts\\"\\nconst useVideoPlayer = (videoElement: React.MutableRefObject<HTMLVideoElement>) => {\\n    ...\\n    // highlight-start\\n    const handleVideoSpeed = (event) => {\\n        const speed = +event.target.value;\\n        videoElement.current.playbackRate = speed;\\n        setPlayerState({\\n            ...playerState,\\n            speed\\n        });\\n    }\\n\\n    const toggleMute = () => {\\n        setPlayerState({\\n            ...isMuted: !playerState.isMuted\\n        });\\n    }\\n    //highlight-end\\n}\\n```\\n\\nAdd `useEffect` hooks that will update the muted state of the video player, the playback speed, and the current play/pause state of the video player when their respective states have been changed.\\n\\n```ts title=\\"src/bands/VideoBand/useVideoPlayer.ts\\"\\n// highlight-next-line\\nimport { useState, useEffect } from \\"react\\";\\n\\nconst useVideoPlayer = (videoElement: React.MutableRefObject<HTMLVideoElement>) => {\\n    ...\\n    // highlight-start\\n    useEffect(() => {\\n        videoElement.current.muted = playerState.isMuted;\\n    }, [playerState.isMuted, videoElement]);\\n\\n    useEffect(() => {\\n        videoElement.current.playbackRate = playerState.speed;\\n    }, [playerState.speed, videoElement]);\\n\\n    useEffect(() => {\\n        playerState.isPlaying ?\\n        void videoElement.current.play() :\\n        void videoElement.current.pause();\\n    }, [playerState.isPlaying, videoElement]);\\n    //highlight-end\\n}\\n```\\n\\nFinally, provide all of these functions to the consumer of the hook by returning an object containing everything needed to create an interactive video player.\\n\\n```ts title=\\"src/bands/VideoBand/useVideoPlayer.ts\\"\\n// highlight-next-line\\nimport { useState, useEffect } from \\"react\\";\\n\\nconst useVideoPlayer = (videoElement: React.MutableRefObject<HTMLVideoElement>) => {\\n    ...\\n    // highlight-start\\n    return {\\n        playerState,\\n        togglePlay,\\n        handleOnTimeUpdate,\\n        handleVideoSpeed,\\n        toggleMute,\\n        seekTo\\n    }\\n    //highlight-end\\n}\\n```\\n\\nWith everything put together, your `useVideoPlayer` hook should look like this:\\n\\n```ts title=\\"src/bands/VideoBand/useVideoPlayer.ts\\"\\nimport { useState, useEffect } from \\"react\\";\\n\\nconst useVideoPlayer = (\\n    videoElement: React.MutableRefObject<HTMLVideoElement>\\n) => {\\n    const [playerState, setPlayerState] = useState({\\n        isPlaying: false,\\n        progress: 0,\\n        speed: 1,\\n        isMuted: false,\\n    });\\n\\n    const togglePlay = () => {\\n        setPlayerState({\\n            ...playerState,\\n            isPlaying: !playerState.isPlaying,\\n        });\\n    };\\n\\n    const handleOnTimeUpdate = () => {\\n        const progress =\\n            (videoElement.current.currentTime /\\n                videoElement.current.duration) *\\n            100;\\n        setPlayerState({\\n            ...playerState,\\n            progress,\\n        });\\n    };\\n\\n    const seekTo = (value: number) => {\\n        if (value >= 0 && value <= 100) {\\n            videoElement.current.currentTime =\\n                (videoElement.current.duration / 100) * value;\\n            setPlayerState({\\n                ...playerState,\\n                progress: value,\\n            });\\n        }\\n    };\\n\\n    const handleVideoSpeed = (event) => {\\n        const speed = +event.target.value;\\n        videoElement.current.playbackRate = speed;\\n        setPlayerState({\\n            ...playerState,\\n            speed,\\n        });\\n    };\\n\\n    const toggleMute = () => {\\n        setPlayerState({\\n            ...playerState,\\n            isMuted: !playerState.isMuted,\\n        });\\n    };\\n\\n    useEffect(() => {\\n        videoElement.current.muted = playerState.isMuted;\\n    }, [playerState.isMuted, videoElement]);\\n\\n    useEffect(() => {\\n        videoElement.current.playbackRate = playerState.speed;\\n    }, [playerState.speed, videoElement]);\\n\\n    useEffect(() => {\\n        playerState.isPlaying\\n            ? void videoElement.current.play()\\n            : void videoElement.current.pause();\\n    }, [playerState.isPlaying, videoElement]);\\n\\n    return {\\n        playerState,\\n        togglePlay,\\n        handleOnTimeUpdate,\\n        handleVideoSpeed,\\n        toggleMute,\\n        seekTo,\\n    };\\n};\\n\\nexport default useVideoPlayer;\\n```\\n\\n### Creating the component\\n\\nNow, add the hook to your custom band. Open `src/bands/VideoBand/Band.tsx`. Here you will find a simple react component. This component is the entrypoint for the band. In the `Band` component, add a `player` ref and add your `useVideoPlayer` hook. Add the `props` function parameter to the component.\\n\\n```tsx title=\\"src/bands/VideoBand/Band.tsx\\"\\nimport React, { useRef } from \\"react\\";\\nimport { BandProps } from \\"inline\\";\\nimport \\"./Band.css\\";\\nimport useVideoPlayer from \\"./useVideoPlayer\\";\\n\\nexport const Band: React.FC<BandProps> = (props) => {\\n    const player = useRef<HTMLVideoElement>();\\n    const {\\n        playerState,\\n        togglePlay,\\n        handleOnTimeUpdate,\\n        handleVideoSpeed,\\n        toggleMute,\\n        seekTo,\\n    } = useVideoPlayer(player);\\n\\n    return <div className=\\"video-band\\">Video Band</div>;\\n};\\n```\\n\\nAdd a video player and controls in a wrapper in the return statement of the component. The video player will take the URL to your video, player ref and the `handleOnTimeUpdate` function as props to the video player. The URL will be accessed using the `band.customBandSettings` prop passed in to the custom band.\\n\\n:::note\\nThis custom video band only works with hosted videos, not embedded video players.\\n:::\\n\\n```tsx title=\\"src/bands/VideoBand/Band.tsx\\"\\nreturn (\\n    <div className=\\"video-band\\">\\n        // highlight-start\\n        <div className=\\"video-wrapper\\">\\n            <video\\n                ref={player}\\n                onTimeUpdate={handleOnTimeUpdate}\\n                src={props.band.customBandSettings.url ?? \\"\\"}\\n            />\\n            <div className=\\"controls\\"></div>\\n        </div>\\n        // highlight-end\\n    </div>\\n);\\n```\\n\\nThe first control we will add is the start/stop button. This will show an icon depending on whether the video is playing or paused. To use that icon we need to install an npm package, `react-icons`. Run\\n\\n```\\nnpm install react-icons\\n```\\n\\nin the terminal to install all the icons you will need for this project.\\n\\n```tsx title=\\"src/bands/VideoBand/Band.tsx\\"\\nimport { BiPlay, BiPause} from \\"react-icons/bi\\";\\n...\\nreturn (\\n    <div className=\\"video-band\\">\\n        <div className=\\"video-wrapper\\">\\n            ...\\n            <div className=\\"controls\\">\\n                // highlight-start\\n                <div className=\\"actions\\">\\n                    <button onClick={togglePlay}>\\n                        {!playerState.isPlaying ? (\\n                            <BiPlay color=\\"white\\" />\\n                        ) : (\\n                            <BiPause color=\\"white\\" />\\n                        )}\\n                    </button>\\n                </div>\\n                // highlight-end\\n            </div>\\n        </div>\\n    </div>\\n);\\n```\\n\\nAdd a progress bar that allows the user to seek through the length of the video and shows the current timestamp of the video. We also need to add a function to handle the input\'s onChange prop.\\n\\n```tsx title=\\"src/bands/VideoBand/Band.tsx\\"\\n// highlight-start\\nconst handleVideoProgress = (event: React.ChangeEvent<HTMLInputElement>) => {\\n    const value = isNaN(+event.target.value) ? 0 : +event.target.value;\\n    seekTo(value);\\n}\\n// highlight-end\\n\\nreturn (\\n    <div className=\\"video-band\\">\\n        <div className=\\"video-wrapper\\">\\n            ...\\n            <div className=\\"controls\\">\\n                {...}\\n                // highlight-start\\n                <input\\n                    type=\\"range\\"\\n                    min=\\"0\\"\\n                    max=\\"100\\"\\n                    value={playerState.progress}\\n                    onChange={handleVideoProgress}\\n                />\\n                // highlight-end\\n            </div>\\n        </div>\\n    </div>\\n);\\n```\\n\\nAdd a dropdown with some options for different playback speeds.\\n\\n```tsx title=\\"src/bands/VideoBand/Band.tsx\\"\\nreturn (\\n    <div className=\\"video-band\\">\\n        <div className=\\"video-wrapper\\">\\n            ...\\n            <div className=\\"controls\\">\\n                {...}\\n                // highlight-start\\n                <select\\n                    className=\\"velocity\\"\\n                    value={playerState.speed}\\n                    onChange={handleVideoSpeed}\\n                >\\n                    <option value=\\"0.50\\">0.50</option>\\n                    <option value=\\"1\\">1</option>\\n                    <option value=\\"1.25\\">1.25</option>\\n                    <option value=\\"2\\">2</option>\\n                </select>\\n                // highlight-end\\n            </div>\\n        </div>\\n    </div>\\n);\\n```\\n\\nThe last thing to add is the mute button.\\n\\n```tsx title=\\"src/bands/VideoBand/Band.tsx\\"\\nreturn (\\n    <div className=\\"video-band\\">\\n        <div className=\\"video-wrapper\\">\\n            ...\\n            <div className=\\"controls\\">\\n                {...}\\n                // highlight-start\\n                <button className=\\"mute-btn\\" onClick={toggleMute}>\\n                    {!playerState.isMuted ? (\\n                        <BiVolumeFull color=\\"white\\"/>\\n                    ) : (\\n                        <BiVolumeMute color=\\"white\\"/>\\n                    )}\\n                </button>\\n                // highlight-end\\n            </div>\\n        </div>\\n    </div>\\n);\\n```\\n\\nWith everything added your component should look like this:\\n\\n```tsx title=\\"src/bands/VideoBand/Band.tsx\\"\\nimport debounce from \\"lodash.debounce\\";\\nimport {\\n    BiPlay,\\n    BiPause,\\n    BiVolumeFull,\\n    BiVolumeMute,\\n} from \\"react-icons/bi\\";\\nimport React, { useEffect, useRef } from \\"react\\";\\nimport useVideoPlayer from \\"./useVideoPlayer\\";\\nimport \\"./Band.css\\";\\nimport { BandProps } from \\"inline\\";\\n\\nexport const Band: React.FC<BandProps> = (props) => {\\n    const player = useRef<HTMLVideoElement>();\\n    const {\\n        playerState,\\n        togglePlay,\\n        handleOnTimeUpdate,\\n        handleVideoSpeed,\\n        toggleMute,\\n        seekTo,\\n    } = useVideoPlayer(player);\\n\\n    const handleVideoProgress = (\\n        event: React.ChangeEvent<HTMLInputElement>\\n    ) => {\\n        const value = isNaN(+event.target.value)\\n            ? 0\\n            : +event.target.value;\\n        seekTo(value);\\n    };\\n\\n    return (\\n        <div className=\\"video-band container\\">\\n            <div className=\\"video-wrapper\\">\\n                <video\\n                    ref={player}\\n                    onTimeUpdate={handleOnTimeUpdate}\\n                    src={props.band.customBandSettings.url ?? \\"\\"}\\n                />\\n                <div className=\\"controls\\">\\n                    <div className=\\"actions\\">\\n                        <button onClick={togglePlay}>\\n                            {!playerState.isPlaying ? (\\n                                <BiPlay color=\\"white\\" />\\n                            ) : (\\n                                <BiPause color=\\"white\\" />\\n                            )}\\n                        </button>\\n                    </div>\\n                    <input\\n                        type=\\"range\\"\\n                        min=\\"0\\"\\n                        max=\\"100\\"\\n                        value={playerState.progress}\\n                        onChange={handleVideoProgress}\\n                    />\\n                    <select\\n                        className=\\"velocity\\"\\n                        value={playerState.speed}\\n                        onChange={handleVideoSpeed}\\n                    >\\n                        <option value=\\"0.50\\">0.50</option>\\n                        <option value=\\"1\\">1</option>\\n                        <option value=\\"1.25\\">1.25</option>\\n                        <option value=\\"2\\">2</option>\\n                    </select>\\n                    <button className=\\"mute-btn\\" onClick={toggleMute}>\\n                        {!playerState.isMuted ? (\\n                            <BiVolumeFull color=\\"white\\" />\\n                        ) : (\\n                            <BiVolumeMute color=\\"white\\" />\\n                        )}\\n                    </button>\\n                </div>\\n            </div>\\n        </div>\\n    );\\n};\\n```\\n\\n### Styling the band\\n\\nWith the band created let\'s add some styling. Add this to the `src/bands/VideoBand/Band.css` file:\\n\\n```css title=\\"src/bands/VideoBand/Band.css\\"\\n.video-band.container {\\n    display: flex;\\n    justify-content: center;\\n    align-items: center;\\n    padding: 2rem;\\n    width: 100%;\\n}\\n\\n.video-band h1 {\\n    color: white;\\n}\\n\\n.video-band video {\\n    width: 100%;\\n}\\n\\n.video-band .video-wrapper {\\n    width: 100%;\\n    max-width: 700px;\\n    position: relative;\\n    display: flex;\\n    justify-content: center;\\n    overflow: hidden;\\n    border-radius: 10px;\\n}\\n\\n.video-band .video-wrapper:hover .controls {\\n    transform: translateY(0%);\\n}\\n\\n.video-band .controls {\\n    display: flex;\\n    align-items: center;\\n    justify-content: space-evenly;\\n    position: absolute;\\n    bottom: 30px;\\n    padding: 14px;\\n    width: 100%;\\n    max-width: 500px;\\n    flex-wrap: wrap;\\n    background: rgba(255, 255, 255, 0.25);\\n    box-shadow: 0 8px 32px 0 rgba(255, 255, 255, 0.1);\\n    backdrop-filter: blur(4px);\\n    -webkit-backdrop-filter: blur(4px);\\n    border-radius: 10px;\\n    border: 1px solid rgba(255, 255, 255, 0.18);\\n    transform: translateY(150%);\\n    transition: all 0.3s ease-in-out;\\n}\\n\\n.video-band .actions button {\\n    background: none;\\n    border: none;\\n    outline: none;\\n    cursor: pointer;\\n}\\n\\n.video-band .actions button i {\\n    background-color: none;\\n    color: white;\\n    font-size: 30px;\\n}\\n\\ninput[type=\\"range\\"] {\\n    -webkit-appearance: none !important;\\n    background: rgba(255, 255, 255, 0.2);\\n    border-radius: 20px;\\n    height: 4px;\\n    width: 350px;\\n}\\n\\n.video-band input[type=\\"range\\"]::-webkit-slider-thumb {\\n    -webkit-appearance: none !important;\\n    cursor: pointer;\\n    height: 6px;\\n}\\n\\n.video-band input[type=\\"range\\"]::-moz-range-progress {\\n    background: white;\\n}\\n\\n.video-band .velocity {\\n    appearance: none;\\n    background: none;\\n    color: white;\\n    outline: none;\\n    border: none;\\n    text-align: center;\\n    font-size: 16px;\\n}\\n\\n.video-band .mute-btn {\\n    background: none;\\n    border: none;\\n    outline: none;\\n    cursor: pointer;\\n}\\n\\n.video-band .mute-btn i {\\n    background-color: none;\\n    color: white;\\n    font-size: 20px;\\n}\\n```\\n\\n## Deploying the band\\n\\n### Build the band\\n\\nNow that the band has been created, we can add it to VertiGIS Studio Web and load it into Inline. In the terminal, run\\n\\n```\\nnpm run start\\n```\\n\\nThis will start up a development server and create a temporary build of your custom band.\\n\\n### Adding the band to your app\\n\\nOpen VertiGIS Studio Web Designer. In Web Designer, open your Inline app.\\n\\n:::note\\nIf you do not have an existing Inline app you can create a new app using the VertiGIS Inline template.\\n:::\\n\\nIn your app, open the File menu. Open the Upload Library settings:\\n\\n<img src={useBaseUrl(\\"img/app-designer-upload-library.png\\")} />\\n\\nIn the popup, add `http://localhost:4444/main.js` as a library URL:\\n\\n<img src={useBaseUrl(\\"img/app-designer-upload-library-modal.png\\")} />\\n\\nClick the `Add Library` button beside the library link input. Click Save Changes. Your app will be saved and be refreshed.\\n\\nWith this done you can close Web Designer and open the Inline Designer.\\n\\n### Using a custom Web App in Inline\\n\\nIn the Inline designer, open the view you want to add the band to.\\n\\nOpen the Sandbox settings on the left side panel:\\n\\n<img src={useBaseUrl(\\"img/inline-sandbox-settings.png\\")} />\\n\\nAt the top of the panel, select `Change Web App`. This will open a window with a list of your VertiGIS Studio Web apps. Choose the Web app that you added your custom band library to.\\n\\nYou can confirm that the custom bands have been loaded by checking your browser console. You should see a console log for each band that has been loaded.\\n\\n<img src={useBaseUrl(\\"img/inline-custom-band-console.png\\")} />\\n\\n### Adding the custom band to your view\\n\\nWith Inline running your custom Web app, you can now add your band to your view using the Inline designer.\\n\\nAdd a new band to Inline. Open the new Band settings. In the `Band Type` dropdown choose \\"Custom\\".\\n\\n<img src={useBaseUrl(\\"img/inline-band-type-dropdown.png\\")} />\\n\\nIn the `Custom Band Name` dropdown, choose \\"VideoBand\\".\\n\\n<img src={useBaseUrl(\\"img/inline-band-name-dropdown.png\\")} />\\n\\nYou should see a new settings section with the option to add a Video URL. Add a URL to a `Video URL` setting.\\n\\n:::note\\nCustom bands will sometimes require a refresh of the Inline sandbox before you can see them reflected in the charts. Click the `Refresh Sandbox` button in the top left of the Inline designer if you are not seeing your custom band in your view.\\n:::\\n\\nChoose a route and range for your view. When the bands load you should see your custom video band playing with your video. Hovering over the video should show the video controls.\\n\\n<img src={useBaseUrl(\\"img/inline-video-band.png\\")} />\\n\\n## Syncing the band with Inline\\n\\nThe band that we have now will show and run a video with all the controls, but it won\'t sync with the rest of your Inline bands. In order to do that we need to listen to some inline events. The Inline SDK allows custom bands to listen for and fire any Inline events. Types and descriptions for these events can be found in the `definitions/Inline.d.ts` file in the project.\\n\\nOpen VS Code and the `src/bands/VideoBand/Band.tsx` file. Add a new `useEffect` hook to the Band component.\\n\\n```tsx title=\\"src/bands/VideoBand/Band.tsx\\"\\n// highlight-next-line\\nimport React, { useEffect, useRef } from \\"react\\";\\n...\\nexport const Band: React.FC<BandProps> = (props) => {\\n    ...\\n\\n    // highlight-next-line\\n    useEffect(() => {})\\n\\n    return(...)\\n}\\n```\\n\\nIn the `useEffect` hook we will add some Inline event handlers using the `InlineManager` that is passed to the component via the props.\\n\\n:::note\\nThe `InlineManager` has a variety of different tools that can be used from within a custom band that can change how you interact with Inline. Many of the tools are typed in the Inline SDK and can be found in the `definitions/Inline.d.ts` file.\\n:::\\n\\n```tsx title=\\"src/bands/VideoBand/Band.tsx\\"\\nuseEffect(() => {\\n    const mapCrosshairEvent = props.InlineManager.event(\\n        \\"ChartCrosshairLocationUpdateEvent\\"\\n    ).subscribe(undefined, handleCrosshairPositionChangeEvent);\\n    const chartCrosshairEvent = props.InlineManager.event(\\n        \\"XValueChangeEvent\\"\\n    ).subscribe(undefined, handleCrosshairPositionChangeEvent);\\n\\n    return () => {\\n        props.InlineManager.event(\\n            \\"ChartCrosshairLocationUpdateEvent\\"\\n        ).unsubscribe(mapCrosshairEvent);\\n        props.InlineManager.event(\\"XValueChangeEvent\\").unsubscribe(\\n            chartCrosshairEvent\\n        );\\n    };\\n});\\n```\\n\\nThere are two different events that we are listening for here. The `ChartCrosshairLocationUpdateEvent` is fired when the route is hovered over on the map. The `XValueChangeEvent` is fired when a chart is hovered over. Both of these will provide the same arguments and can be dealt with via the same handler.\\n\\nAdd a new function, `handleCrosshairPositionChangeEvent`, under the `useEffect` hook. This function will update the progress of the video to match the current location of the crosshair on the chart.\\n\\n```tsx title=\\"src/bands/VideoBand/Band.tsx\\"\\n// highlight-next-line\\nimport { BandProps, StationInfoEventArg } from \\"inline\\";\\n...\\nexport const Band: React.FC<BandProps> = (props) => {\\n    ...\\n\\n    // highlight-start\\n    const handleCrosshairPositionChangeEvent = (\\n        arg: StationInfoEventArg\\n    ) => {\\n        // Don\'t try to update the position if the video player does not exist.\\n        if (!player.current) {\\n            return;\\n        }\\n\\n        // Get the start and end measure of the current range to calculate the\\n        // percent along the line.\\n        const start =\\n            props.InlineManager.currentRange.beginStation.measure;\\n        const end = props.InlineManager.currentRange.endStation.measure;\\n\\n        // Ensure the measure is within the range.  If it is not, clamp it to prevent\\n        // any errors.\\n        const measure = Math.max(\\n            start,\\n            Math.min(end, arg.stationInfo.measure)\\n        );\\n\\n        const currentRangeLength = end - start;\\n        const percentageAlongLine =\\n            (measure - start) / currentRangeLength;\\n\\n        // Move the video progress to the corresponding percentage through the video\\n        // that matches the percentage along the line.\\n        seekTo(percentageAlongLine * 100);\\n\\n        // Pause the video to be able to see where the position that was jumped to is.\\n        if (playerState.isPlaying) {\\n            togglePlay();\\n        }\\n    };\\n    // highlight-end\\n\\n    return(...)\\n}\\n```\\n\\nThe last thing we want to do is add a debounce to the handler to prevent any performance issues that can happen when moving around a lot. Install Lodash\'s debounce tool with\\n\\n```\\nnpm install lodash.debounce\\n```\\n\\nWrap the `handleCrosshairPositionChangeEvent` in a debounce higher order function. Give the debounce a 100ms refresh argument. Create and add a type, `StationInfoEventHandler`, to the function.\\n\\n```tsx title=\\"src/bands/VideoBand/Band.tsx\\"\\n// highlight-next-line\\nimport debounce from \\"lodash.debounce\\";\\n...\\n// highlight-next-line\\ntype StationInfoEventHandler = (arg: StationInfoEventArg) => void;\\n\\nexport const Band: React.FC<BandProps> = (props) => {\\n    ...\\n\\n    // highlight-start\\n    const handleCrosshairPositionChangeEvent: StationInfoEventHandler = debounce((arg: StationInfoEventArg) => {\\n        ...\\n    }, [100])\\n    // highlight-end\\n\\n    return(...)\\n}\\n```\\n\\nWith the event handler and the event listeners added, the `Band.tsx` file should look like this:\\n\\n```tsx title=\\"src/bands/VideoBand/Band.tsx\\"\\nimport debounce from \\"lodash.debounce\\";\\nimport {\\n    BiPlay,\\n    BiPause,\\n    BiVolumeFull,\\n    BiVolumeMute,\\n} from \\"react-icons/bi\\";\\nimport React, { useEffect, useRef } from \\"react\\";\\nimport useVideoPlayer from \\"./useVideoPlayer\\";\\nimport \\"./Band.css\\";\\nimport { BandProps, StationInfoEventArg } from \\"inline\\";\\n\\nexport const Band: React.FC<BandProps> = (props) => {\\n    const player = useRef<HTMLVideoElement>();\\n    const {\\n        playerState,\\n        togglePlay,\\n        handleOnTimeUpdate,\\n        handleVideoSpeed,\\n        toggleMute,\\n        seekTo,\\n    } = useVideoPlayer(player);\\n\\n    /**\\n     * Subscribing to inline events can allow for better integration of custom bands into inline.\\n     */\\n    useEffect(() => {\\n        const mapCrosshairEvent = props.InlineManager.event(\\n            \\"ChartCrosshairLocationUpdateEvent\\"\\n        ).subscribe(undefined, handleCrosshairPositionChangeEvent);\\n        const chartCrosshairEvent = props.InlineManager.event(\\n            \\"XValueChangeEvent\\"\\n        ).subscribe(undefined, handleCrosshairPositionChangeEvent);\\n        return () => {\\n            props.InlineManager.event(\\n                \\"ChartCrosshairLocationUpdateEvent\\"\\n            ).unsubscribe(mapCrosshairEvent);\\n            props.InlineManager.event(\\n                \\"XValueChangeEvent\\"\\n            ).unsubscribe(chartCrosshairEvent);\\n        };\\n    });\\n\\n    /**\\n     * When the inline cursor moves, it should update the video progress to match.\\n     */\\n    const handleCrosshairPositionChangeEvent = debounce(\\n        (arg: StationInfoEventArg) => {\\n            // Don\'t try to update the position if the video player does not exist.\\n            if (!player.current) {\\n                return;\\n            }\\n\\n            // Get the start and end measure of the current range to calculate the\\n            // percent along the line.\\n            const start =\\n                props.InlineManager.currentRange.beginStation.measure;\\n            const end =\\n                props.InlineManager.currentRange.endStation.measure;\\n\\n            // Ensure the measure is within the range.  If it is not, clamp it to prevent\\n            // any errors.\\n            const measure = Math.max(\\n                start,\\n                Math.min(end, arg.stationInfo.measure)\\n            );\\n\\n            const currentRangeLength = end - start;\\n            const percentageAlongLine =\\n                (measure - start) / currentRangeLength;\\n\\n            // Move the video progress to the corresponding percentage through the video\\n            // that matches the percentage along the line.\\n            seekTo(percentageAlongLine * 100);\\n\\n            // Pause the video to be able to see where the position that was jumped to is.\\n            if (playerState.isPlaying) {\\n                togglePlay();\\n            }\\n        },\\n        [100]\\n    );\\n\\n    const handleVideoProgress = (\\n        event: React.ChangeEvent<HTMLInputElement>\\n    ) => {\\n        const value = isNaN(+event.target.value)\\n            ? 0\\n            : +event.target.value;\\n        seekTo(value);\\n    };\\n\\n    return (\\n        <div className=\\"video-band container\\">\\n            <div className=\\"video-wrapper\\">\\n                <video\\n                    src={props.band.customBandSettings.url ?? \\"\\"}\\n                    ref={player}\\n                    onTimeUpdate={handleOnTimeUpdate}\\n                />\\n                <div className=\\"controls\\">\\n                    <div className=\\"actions\\">\\n                        <button onClick={togglePlay}>\\n                            {!playerState.isPlaying ? (\\n                                <BiPlay color=\\"white\\" />\\n                            ) : (\\n                                <BiPause color=\\"white\\" />\\n                            )}\\n                        </button>\\n                    </div>\\n                    <input\\n                        type=\\"range\\"\\n                        min=\\"0\\"\\n                        max=\\"100\\"\\n                        value={playerState.progress}\\n                        onChange={handleVideoProgress}\\n                    />\\n                    <select\\n                        className=\\"velocity\\"\\n                        value={playerState.speed}\\n                        onChange={handleVideoSpeed}\\n                    >\\n                        <option value=\\"0.50\\">0.50</option>\\n                        <option value=\\"1\\">1</option>\\n                        <option value=\\"1.25\\">1.25</option>\\n                        <option value=\\"2\\">2</option>\\n                    </select>\\n                    <button className=\\"mute-btn\\" onClick={toggleMute}>\\n                        {!playerState.isMuted ? (\\n                            <BiVolumeFull color=\\"white\\" />\\n                        ) : (\\n                            <BiVolumeMute color=\\"white\\" />\\n                        )}\\n                    </button>\\n                </div>\\n            </div>\\n        </div>\\n    );\\n};\\n```\\n\\nSave the file. Open the Inline designer with the view configured with your custom band. Reload the page to get your new changes. You should be able to see the video scrub through as you hover over the charts and the map.\\n\\n## Production Build\\n\\nOnce you have a custom band working how you would like, you can create a optimized production build. In a terminal run\\n\\n```\\nnpm run build\\n```\\n\\nThis will create a `build` folder with a `main.js` file. We can replace the library link we previously added with the `main.js` file and your custom band will be accessible to anyone who uses your app.\\n\\nIn Web Designer, open the Upload Library panel. Remove the custom library URL. Save the changes.\\n\\n:::danger Warning\\nOnly remove the custom library URL, `http://localhost:4444/main.js`. Removing the Inline library can break your app and cause unexpected behavior.\\n:::\\n\\n:::danger Warning\\nSave your changes before uploading another library. Loading two libraries with the same service can cause unexpected behavior in Web Designer, including losing access to your app.\\n:::\\n\\nAfter saving the changes and reloading your app, Open the Update Library panel again. Instead of adding a URL, upload a file. Browse to your `<Inline SDK folder>/build/main.js`. Upload the file and save the changes.\\n\\nReturn to your Inline Designer. Reload the page. The custom band should work as expected.\\n\\n## Conclusion\\n\\nWith the information learned in this post you should be able to create your own custom Inline band. The sample band can be a great place to start and explore everything the Inline SDK can do. Using Inline events and the InlineManager can give you even more powerful tools to use in your custom bands, including running VertiGIS Studio Web Commands and Operations and even VertiGIS Studio Workflows!"},{"id":"/2023/03/01/mobile-generic-event-listener","metadata":{"permalink":"/blog/2023/03/01/mobile-generic-event-listener","source":"@site/blog/2023-03-01-mobile-generic-event-listener.mdx","title":"Mobile Generic Event Listener","description":"VertiGIS Studio Mobile 5.22 includes an exciting new capability for working with commands, operations, and events. This capability allows app authors to execute custom, configured actions in response to events raised in Mobile. To opt in to this behavior, app authors register an event listener (subscriber) for any given Mobile event. When this event is raised in Mobile, the corresponding configured command or operation is invoked.","date":"2023-03-01T00:00:00.000Z","tags":[{"label":"mobile","permalink":"/blog/tags/mobile"},{"label":"workflow","permalink":"/blog/tags/workflow"}],"readingTime":7.065,"hasTruncateMarker":true,"authors":[{"name":"Kenneth Walker","title":"Software Developer","url":"https://github.com/kewalker","imageURL":"https://github.com/kewalker.png"}],"frontMatter":{"title":"Mobile Generic Event Listener","author":"Kenneth Walker","authorTitle":"Software Developer","authorURL":"https://github.com/kewalker","authorImageURL":"https://github.com/kewalker.png","tags":["mobile","workflow"]},"unlisted":false,"prevItem":{"title":"Creating Custom Bands with the Inline SDK","permalink":"/blog/2023/06/20/inline-sdk"},"nextItem":{"title":"New Workflow Form Element API","permalink":"/blog/2021/03/22/new-workflow-element-api"}},"content":"import Link from \\"@docusaurus/Link\\";\\n\\nVertiGIS Studio Mobile `5.22` includes an exciting new capability for working with commands, operations, and events. This capability allows app authors to execute custom, configured actions in response to events raised in Mobile. To opt in to this behavior, app authors register an event listener (subscriber) for any given Mobile event. When this event is raised in Mobile, the corresponding configured command or operation is invoked.\\n\\n\x3c!--truncate--\x3e\\n\\n:::note\\nTo use these new features, you will need a `5.22+` version of VertiGIS Studio Mobile.\\n:::\\n\\nThe new events capability can be exercised in a few ways:\\n\\n-   [Registering an event listener and action](#register-a-listener)\\n-   [Command chaining](#command-chaining)\\n-   [Specifying a sender](#specify-a-sender)\\n-   [Workflow and context](#workflows-and-context)\\n-   [Raise custom event](#raise-custom-events)\\n\\n:::tip Want a complete list of events?\\nCheck out the [Events](https://developers.vertigisstudio.com/docs/mobile/api-events#events) for the complete list of eligible events that can be listened to.\\n:::\\n\\n## Register a Listener\\n\\nTo get started, you\'ll want to introduce a new item `$type` into your `app.json` configuration: the `event-listener`. Today, you\'ll need to manually configure this app item and any respective listeners. Support for configuring listeners through Designer will be coming soon.\\n\\n```json\\n{\\n    \\"$type\\": \\"event-listener\\",\\n    \\"id\\": \\"custom-event-listener\\",\\n    \\"listeners\\": [\\n        // ... to be populated with listeners ...\\n    ]\\n}\\n```\\n\\n### Wire up a new `Listener`\\n\\nWith the new `event-listener` app item, you register a listener to a given event and respond with a configured action. Below, we\'re taking advantage of the [map.viewpoint-changed](https://developers.vertigisstudio.com/docs/mobile/api-events/#event-map.viewpoint-changed) event. In particular, it\'s configured with the [highlights.clear](https://developers.vertigisstudio.com/docs/mobile/api-commands-operations#command-highlights.clear) command. When you pan the map, the `map.viewpoint-changed` event is raised, and in turn, our `highlights.clear` command is executed. No more highlights when we pan!\\n\\n```json\\n{\\n    \\"$type\\": \\"event-listener\\",\\n    \\"id\\": \\"custom-event-listener\\",\\n    \\"listeners\\": [\\n        {\\n            \\"event\\": \\"map.viewpoint-changed\\",\\n            \\"action\\": \\"highlights.clear\\"\\n        }\\n        // ... more listeners ...\\n    ]\\n}\\n```\\n\\nOf course, multiple listeners may be registered. They can listen to both distinct or duplicate events:\\n\\n```json\\n{\\n    \\"$type\\": \\"event-listener\\",\\n    \\"id\\": \\"custom-event-listener\\",\\n    \\"listeners\\": [\\n        {\\n            \\"event\\": \\"map.viewpoint-changed\\",\\n            \\"action\\": \\"highlights.clear\\"\\n        },\\n        {\\n            \\"event\\": \\"map.viewpoint-changed\\",\\n            \\"action\\": \\"highlights.clear-focus\\"\\n        },\\n        {\\n            \\"event\\": \\"layers.visibility-changed\\",\\n            \\"action\\": \\"log-viewer.display\\"\\n        }\\n        // ... more listeners ...\\n    ]\\n}\\n```\\n\\n:::danger Warning\\nThe event listener capability is only available after the map has begun initializing. Listeners for events that fire _before_ the `map.initializing` event will not trigger any actions.\\n:::\\n\\n## Command Chaining\\n\\nWe can pair event listening with [Command Chains](https://developers.vertigisstudio.com/docs/mobile/configuration-commands-operations/#command-chains) to react with multiple actions chained together. In the example below, we\'ll react to a map pan by both clearing highlights and closing the panel. Notice that we can mix the use of simple syntax with the dictionary syntax that can optionally provide arguments.\\n\\n```json\\n{\\n    \\"$type\\": \\"event-listener\\",\\n    \\"id\\": \\"custom-event-listener\\",\\n    \\"listeners\\": [\\n        {\\n            \\"event\\": \\"map.viewpoint-changed\\",\\n            \\"action\\": [\\n                \\"highlights.clear\\",\\n                {\\n                    \\"name\\": \\"panel.close-host-panel\\",\\n                    \\"arguments\\": {}\\n                }\\n            ]\\n        }\\n        // ... more listeners ...\\n    ]\\n}\\n```\\n\\n## Specify A Sender\\n\\nUse the `sender` property to configure the listener such that it **only** reacts to those events that originate from the specified sender. A sender could correspond to a given component or service. Specifying the sender is optional.\\n\\nTake the example below where two `map-extension`s are configured. Since `sender` is specified as \\"map-config-1\\", viewpoint changed events raised from this map will result in highlights being cleared. Viewpoint changed events raised from \\"map-config-2\\" are effectively ignored.\\n\\n```json\\n{\\n    \\"$type\\": \\"map-extension\\",\\n    \\"id\\": \\"map-config-1\\",\\n    \\"webMap\\": \\"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx1\\"\\n    // ...\\n},\\n{\\n    \\"$type\\": \\"map-extension\\",\\n    \\"id\\": \\"map-config-2\\",\\n    \\"webMap\\": \\"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx2\\"\\n    // ...\\n},\\n\\n// ...\\n\\n{\\n    \\"$type\\": \\"event-listener\\",\\n    \\"id\\": \\"custom-event-listener\\",\\n    \\"listeners\\": [\\n        {\\n            \\"event\\": \\"map.viewpoint-changed\\",\\n            \\"sender\\": \\"item://map-extension/map-config-1\\",\\n            \\"action\\": [\\"highlights.clear\\"]\\n        },\\n        // ... more listeners ...\\n    ]\\n}\\n```\\n\\n:::note\\nIf the `sender` is omitted, any instance of the raised event will trigger the configured action.\\n:::\\n\\n## Workflows and Context\\n\\nUsing this new capability, you can also configure a Studio Workflow as an action to invoke in response to an event being raised.\\n\\n:::tip Want to learn more about Studio Workflow?\\nCheck out the overview to learn more about [Studio Workflow](https://developers.vertigisstudio.com/docs/workflow/overview).\\n:::\\n\\nBelow, we\'ll configure a [workflow.run](https://developers.vertigisstudio.com/docs/mobile/api-commands-operations#command-workflow.run) action and listen to a [layers.visibility-changed](https://developers.vertigisstudio.com/docs/mobile/api-events#event-layers.visibility-changed) event. Notice that we can specify arguments for our action, which in this case, will be the `id` of a `$type: \\"workflow\\"` item in `app.json` configuration.\\n\\nIn this example, toggling an entry in the layer list will invoke the configured workflow.\\n\\n```json\\n{\\n    \\"$type\\": \\"event-listener\\",\\n    \\"id\\": \\"custom-event-listener\\",\\n    \\"listeners\\": [\\n        {\\n            \\"event\\": \\"layers.visibility-changed\\",\\n            \\"action\\": {\\n                \\"name\\": \\"workflow.run\\",\\n                \\"arguments\\": {\\n                    \\"id\\": \\"visibility-workflow\\" // this id corresponds to the id of the workflow item that we want to invoke\\n                }\\n            }\\n        },\\n        // ... more listeners ...\\n    ]\\n},\\n\\n// ...\\n\\n{\\n    // The corresponding Workflow that we want to invoke in response to an event.\\n    \\"$type\\": \\"workflow\\",\\n    \\"id\\": \\"visibility-workflow\\",\\n    \\"title\\": \\"My Visibility Workflow\\",\\n    \\"target\\": \\"auto\\",\\n    \\"portalItem\\": \\"https://www.arcgis.com/sharing/rest/content/items/xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\\",\\n    \\"commandArgumentInput\\": \\"context\\"\\n},\\n```\\n\\n### A Workflow with Context\\n\\nRunning a Workflow is a powerful way to react to events raised during an app session. Pairing a Workflow with the `context` capability gives us an opportunity to use an input from the event in the Workflow activity.\\n\\nNotice below that the Workflow item specifies a `commandArgumentInput` value of `context`:\\n\\n```json\\n{\\n    \\"$type\\": \\"workflow\\",\\n    \\"commandArgumentInput\\": \\"context\\"\\n    // ...\\n},\\n```\\n\\nUsing the `layers.visibility-changed` event, we configure a Workflow as an action, being mindful of the `commandArgumentInput`.\\n\\n```json\\n{\\n    \\"$type\\": \\"event-listener\\",\\n    \\"id\\": \\"custom-event-listener\\",\\n    \\"listeners\\": [\\n        {\\n            \\"event\\": \\"layers.visibility-changed\\",\\n            \\"action\\": {\\n                \\"name\\": \\"workflow.run\\",\\n                \\"arguments\\": {\\n                    \\"id\\": \\"visibility-workflow\\" // this id corresponds to the id of the workflow item that we want to invoke\\n                }\\n            }\\n        },\\n        // ... more listeners ...\\n    ]\\n},\\n\\n// ...\\n\\n{\\n    // The corresponding Workflow that we want to invoke in response to an event.\\n    \\"$type\\": \\"workflow\\",\\n    \\"id\\": \\"visibility-workflow\\",\\n    \\"title\\": \\"My Visibility Workflow\\",\\n    \\"target\\": \\"auto\\",\\n    \\"portalItem\\": \\"https://www.arcgis.com/sharing/rest/content/items/xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\\",\\n    \\"commandArgumentInput\\": \\"context\\"\\n},\\n```\\n\\nBy specifying the `context`, we\'re able to retrieve an input value within a Workflow using the [Get Workflow Inputs](https://docs.vertigisstudio.com/workflow/latest/help/get-workflow-inputs.html) activity.\\n\\nIn our Workflow, we would want to run `Get Workflow Inputs` as our first activity to retrieve the input. Once we have the input as an object in our Workflow, we can access the `context` to start working with the input.\\n\\nIn the case of the `layers.visibility-changed` event, we\'re able to retrieve and work with the `LayerContent` as an input to our Workflow. Below is an example of how to access the `LayerContent` from the `context` and get at the `id`, which could then be used in any subsequent activity, for example an alert or a query:\\n\\n```javascript\\n=$getWorkflowInputs1.inputs.context.LayerContent.id.toString()\\n```\\n\\n:::info Important\\nThe value provided to `commandArgumentInput` and the accessor used within the `Get Workflow Inputs` activity object **must** match to correctly access an input (i.e. both `context` in this example).\\n:::\\n\\n## Raise Custom Events\\n\\nWhile Mobile exposes a number of events that may be listened to, there are times where it would be beneficial to respond to events that _aren\'t_ raised out of the box. Fortunately, there are also capabilities that allow app authors to raise custom events.\\n\\n### Raise Event through Action\\n\\nUsing the new [viewer.publish-event](https://developers.vertigisstudio.com/docs/mobile/api-commands-operations#command-viewer.publish-event) command, a custom event can be raised. This action can be configured anywhere in the app that supports actions, like buttons, hooks, command chains, etc. Below is an example of a configured button action:\\n\\n```json\\n\\"action\\": {\\n    \\"name\\": \\"viewer.publish-event\\",\\n    \\"arguments\\": {\\n        \\"name\\": \\"custom.raised-event\\",\\n        \\"arguments\\": {}\\n    }\\n}\\n```\\n\\n### Raise Event through Workflow\\n\\nBut what if we want to raise a custom event during execution of a Workflow? Using the [Publish Event](https://docs.vertigisstudio.com/workflow/latest/help/publish-event.html) activity, it\'s possible to raise a custom event from anywhere in your Workflow logic. Simply provide the same custom event name to the `Event Name` input in the `Publish Event` activity. Arguments may also be provided. For the above example, that would be:\\n\\n```json\\ncustom.raised-event\\n```\\n\\n:::note\\nAlthough not recommended, it\'s also possible to use the `viewer.publish-event` command and the `Publish Event` activity to manually publish well-known Mobile events, i.e. `map.viewpoint-changed`.\\n:::\\n\\n### Subscribe to Custom Event\\n\\nOf course, publishing these events is only one side of the capabilities. Using the same mechanism introduced above, these custom raised events can be listened to, and configured with an action to invoke.\\n\\n```json\\n{\\n    \\"$type\\": \\"event-listener\\",\\n    \\"id\\": \\"custom-event-listener\\",\\n    \\"listeners\\": [\\n        {\\n            \\"event\\": \\"custom.raised-event\\",\\n            \\"action\\": \\"...\\"\\n        }\\n    ]\\n}\\n```\\n\\nCustom events could in turn raise more events with the `viewer.publish-event`, which could in turn be listened to. Together, the publishing and listening capabilities offer flexibility to respond to custom events with configured actions.\\n\\n## In Closing\\n\\nWe\'re excited to showcase these new capabilities for commands, operations, and events. We hope app authors can take advantage of them to create more responsive and exciting applications. Happy building!"},{"id":"/2021/03/22/new-workflow-element-api","metadata":{"permalink":"/blog/2021/03/22/new-workflow-element-api","source":"@site/blog/2021-03-22-new-workflow-element-api.mdx","title":"New Workflow Form Element API","description":"Workflow 5.21 includes a new TypeScript form element API that you can use for building custom form elements using the VertiGIS Studio Workflow TypeScript SDK. The existing patterns and APIs you\'ve been using for years to build custom form elements will continue to work, but we encourage you to try the new API when building new form elements.","date":"2021-03-22T00:00:00.000Z","tags":[{"label":"workflow","permalink":"/blog/tags/workflow"}],"readingTime":9.06,"hasTruncateMarker":true,"authors":[{"name":"Ian Schmitz","title":"Software Architect","url":"https://github.com/ianschmitz","imageURL":"https://github.com/ianschmitz.png"}],"frontMatter":{"title":"New Workflow Form Element API","author":"Ian Schmitz","authorTitle":"Software Architect","authorURL":"https://github.com/ianschmitz","authorImageURL":"https://github.com/ianschmitz.png","tags":["workflow"]},"unlisted":false,"prevItem":{"title":"Mobile Generic Event Listener","permalink":"/blog/2023/03/01/mobile-generic-event-listener"}},"content":"import Link from \\"@docusaurus/Link\\";\\n\\nWorkflow `5.21` includes a new TypeScript form element API that you can use for building custom form elements using the <Link to=\\"/docs/workflow/sdk-web-overview\\">VertiGIS Studio Workflow TypeScript SDK</Link>. The existing patterns and APIs you\'ve been using for years to build custom form elements will continue to work, but we encourage you to try the new API when building new form elements.\\n\\n\x3c!--truncate--\x3e\\n\\n:::note\\nTo use these new features, you will need the latest version of VertiGIS Studio Workflow, as well as the VertiGIS Studio Workflow SDK.\\n:::\\n\\nThe new form element API provides a number of new features and benefits:\\n\\n-   [New state management API](#new-state-management-api)\\n-   [Simplified element registration](#simplified-element-registration)\\n\x3c!-- Both UI (form re-renders) and element state --\x3e\\n-   [Improved UI consistency](#improved-ui-consistency)\\n\\n## New State Management API\\n\\nWe\'ve created a new state management API that improves custom form element development in a number of ways. Let\'s take a look in-depth at what\'s changed.\\n\\n### Improved `props` interface\\n\\nWe now provide an easy way to extend the props interface with additional public properties for your element. We\'ve also flattened the element\'s properties from `props.element` onto the root of the `props` object and have removed unused properties that were used internally in the product but didn\'t make sense for most custom form elements:\\n\\n```diff\\n- import { CustomFormElementProps } from \\"@geocortex/workflow/runtime/app/RegisterCustomFormElementBase\\";\\n+ import { FormElementProps } from \\"@geocortex/workflow/runtime\\";\\n\\n\\n// The generic type argument provided to `FormElementProps`\\n// allows you to specify the type of `value`.\\n// This will strongly type `props.value` and `props.setValue()`.\\n// You can now add additional properties to your element\'s\\n// props interface. Previously there wasn\'t a great pattern\\n// to declare additional properties for an element.\\n+ interface DemoElementProps extends FormElementProps<number> {\\n+    foo: string;\\n+ }\\n\\n\\n- function DemoElement(props: CustomFormElementProps) {\\n+ function DemoElement(props: DemoElementProps) {\\n    // Get the current `value`. Previously `value` wouldn\'t be\\n    // strongly typed. Here we\'ve typed as `number` as declared\\n    // in our interface above.\\n-   const currentValue = props.element.value;\\n+   const currentValue = props.value;\\n\\n\\n    // Get a custom `foo` property used by my element.\\n+   const currentFoo = props.foo;\\n\\n\\n    // ...\\n}\\n```\\n\\n### `setValue()` and `setProperty()`\\n\\nThese new APIs are included in the props interface and help to improve developer experience and ensure form consistency of both the UI presentation, but also the underlying element state.\\n\\nWe\'ve added the `setProperty()` API which is used to update properties of your element, such as additional public properties that you\'ve added to your element by extending the `FormElementProps` interface.\\n\\nWe\'ve also added `setValue()`. `setValue(value)` is equivalent to calling `setProperty(\\"value\\", value)`. Using the previous API, developers had to remember to raise the `changed` event when updating the `value` property on their element. This was necessary so that workflow authors could run sub-workflows on the `change` event of the element. This is no longer needed as the `setValue()` API will automatically raise the `changed` event for you.\\n\\nAdditionally, the previous patterns didn\'t guarantee that the form would re-render after updating the properties of your element and could result in some challenging UI and data consistency issues. By using the `setProperty()` and `setValue()` APIs, your form will automatically be re-rendered to ensure that the UI shows the most up-to-date state at all times.\\n\\n```diff\\n// Get the current `value`.\\n- const currentValue = props.element.value;\\n+ const currentValue = props.value;\\n\\n\\n// Update the element\'s value.\\n- props.element.value = value;\\n- props.raiseEvent(\\"changed\\", value);\\n+ props.setValue(value);\\n\\n\\n// Get a custom `foo` property used by my element.\\n- const currentFoo = (props.element as any).foo;\\n+ const currentFoo = props.foo;\\n\\n\\n// Set the element\'s `foo` property.\\n- (props.element as any).foo = foo;\\n+ props.setProperty(\\"foo\\", foo);\\n```\\n\\n## Simplified Element Registration\\n\\nTo register your custom form elements using the previous API, you would need to create a Workflow activity that registers your element:\\n\\n```ts\\nexport class RegisterDemoElement extends RegisterCustomFormElementBase {\\n    execute(): void {\\n        // Where `DemoElement` refers to a React component.\\n        this.register(\\"Demo\\", DemoElement);\\n    }\\n}\\n```\\n\\nThis added some extra boilerplate that we felt was unnecessary. More importantly it required the workflow author to run this element registration activity _prior_ to running the _Display Form_ activity that used the custom element. This was an awkward step that Workflow authors had to remember to do for their forms to render correctly.\\n\\nWhen registering your element using the new API and the latest version of the Workflow SDK, it is no longer necessary to run the activity prior to _Display Form_:\\n\\n```ts\\nconst DemoElementRegistration: FormElementRegistration<DemoElementProps> =\\n    {\\n        component: DemoElement,\\n        id: \\"Demo\\",\\n    };\\n\\nexport default DemoElementRegistration;\\n```\\n\\n## Improved UI Consistency\\n\\nThe new `setProperty()` and `setValue()` APIs make it much easier to develop Workflow elements using the common patterns developers are familiar with when building React components. Let\'s look at a simple example of a text input element built using the previous API:\\n\\n```tsx\\nfunction Text(props: CustomFormElementProps) {\\n    return (\\n        <input\\n            // When the text input changes, update the element\'s `value`.\\n            onChange={(event) =>\\n                (props.element.value = event.currentTarget.value)\\n            }\\n            // Show the element `value `in the text input.\\n            value={props.element.value}\\n        />\\n    );\\n}\\n```\\n\\nThere are a few gotchas here that are likely not obvious at first glance:\\n\\n1. We forgot to call `props.raiseEvent(\\"changed\\", value)`. If the workflow author tried to run a sub-workflow on the change event of your element, it would never run.\\n1. The re-rendering of the element wasn\'t deterministic previously. Even if we updated `props.element.value` _and_ invoked `props.raiseEvent(\\"changed\\", value)`, there was no guarantee that this element would re-render immediately. In that case the UI wouldn\'t show the updated value, and would be out-of-sync with the underlying state of the element.\\n1. `value` will be `undefined` during the initial render, until the `onChange` fires for the first time. There are ways to work around this such as running a sub-workflow on the `load` event to set the element\'s value, however this makes development awkward.\\n1. Other parts of the system could update the element\'s `value` to a type that the element doesn\'t expect. For example, instead of `value` being a `string` like we expect, the workflow author could accidentally set the value to an `object` using the _Set Form Element Property_ activity.\\n\\nIt was possible to overcome these gotchas, but it required additional logic that often wasn\'t immediately obvious. We\'ve had to overcome these same challenges when writing form elements within Workflow itself.\\n\\nSo how would we build this element using the new APIs and avoid the gotchas described above? Let\'s take a look:\\n\\n```tsx\\ninterface TextProps extends FormElementProps<string> {}\\n\\nfunction Text(props: TextProps) {\\n    return (\\n        <input\\n            // 1. `setValue()` automatically raises the `changed`\\n            // event for you.\\n            onChange={(event) =>\\n                props.setValue(event.currentTarget.value)\\n            }\\n            // 2. The component will be re-rendered immediately by\\n            // using `setValue()`, ensuring that your UI and element\\n            // state are consistent.\\n            value={props.value}\\n        />\\n    );\\n}\\n\\nconst TextElementRegistration: FormElementRegistration<TextProps> = {\\n    component: Text,\\n    id: \\"Text\\",\\n    // 3. We can provide a default value, avoiding the initial\\n    // `undefined` value.\\n    getInitialProperties: () => ({ value: \\"\\" }),\\n    // 4. We can ensure data consistency by sanitizing changes\\n    // to our element\'s properties.\\n    onPropertyChange: ({ properties, property }) => {\\n        if (property === \\"value\\") {\\n            const value = properties[property];\\n\\n            if (typeof value !== \\"string\\") {\\n                throw new Error(\\"Unexpected type\\");\\n            }\\n        }\\n    },\\n};\\n```\\n\\n## Summary\\n\\nSo what does all of this mean in practice? Below we\'ll compare elements built using the new and old APIs.\\n\\n### Simple Use Case\\n\\nHere\'s a simple text input element:\\n\\n#### Before\\n\\nFor the sake of brevity, we\'ve excluded the additional logic that would be needed to overcome the gotchas [described above](#improved-ui-consistency).\\n\\n```tsx\\nimport * as React from \\"react\\";\\nimport { CustomFormElementProps } from \\"@geocortex/workflow/runtime/app/RegisterCustomFormElementBase\\";\\n\\nclass Text extends React.Component<CustomFormElementProps> {\\n    render(props) {\\n        return (\\n            <input\\n                value={props.element.value}\\n                onChange={(event) => {\\n                    this.props.element.value = value;\\n                    this.props.raiseEvent(\\"changed\\", value);\\n                }}\\n            />\\n        );\\n    }\\n}\\n\\n/**\\n * @displayName Text\\n * @category Custom Activities\\n * @description Registers the text input element for use in Display Form.\\n */\\nexport class RegisterTextElement extends RegisterCustomFormElementBase {\\n    execute(): void {\\n        this.register(\\"Text\\", Text);\\n    }\\n}\\n```\\n\\n#### After\\n\\n```tsx\\nimport {\\n    FormElementProps,\\n    FormElementRegistration,\\n} from \\"@geocortex/workflow/runtime\\";\\n\\ninterface TextProps extends FormElementProps<string> {}\\n\\n/**\\n * @displayName Text\\n * @category Custom Activities\\n * @description Displays a text input element.\\n */\\nfunction Text(props: TextProps) {\\n    return (\\n        <input\\n            value={props.value}\\n            onChange={(event) =>\\n                props.setValue(event.currentTarget.value)\\n            }\\n        />\\n    );\\n}\\n\\nconst TextElementRegistration: FormElementRegistration<TextProps> = {\\n    component: Text,\\n    id: \\"Text\\",\\n    getInitialProperties: () => ({\\n        value: \\"Hello World\\",\\n    }),\\n};\\n```\\n\\nNotice that updating the `value` for the element has been simplified by using the `setValue()` API. We\'re also now able to provide a default `value` of `\\"Hello World\\"` using `getInitialProperties`.\\n\\n### Advanced Use Case\\n\\nHere\'s a more advanced element that displays a range slider with configurable min, max, and step settings:\\n\\n#### Before\\n\\n```tsx\\nimport * as React from \\"react\\";\\nimport {\\n    CustomFormElementProps,\\n    RegisterCustomFormElementBase,\\n} from \\"@geocortex/workflow/runtime/app/RegisterCustomFormElementBase\\";\\n\\nclass RangeSlider extends React.Component<CustomFormElementProps> {\\n    render() {\\n        const { element, raiseEvent } = this.props;\\n\\n        return (\\n            <div>\\n                <input\\n                    max={100}\\n                    min={0}\\n                    // Even though we\'re updating the element value, until\\n                    // the element is re-rendered the UI won\'t update.\\n                    onChange={(event) => {\\n                        const value =\\n                            event.currentTarget.valueAsNumber;\\n                        element.value = value;\\n                        raiseEvent(\\"changed\\", value);\\n                    }}\\n                    step={5}\\n                    type=\\"range\\"\\n                    // There\'s no way to guarantee that `value` is always a\\n                    // `number`. A workflow could set the `value` to an\\n                    // unexpected type such as by using the\\n                    // `Set Form Element Property` activity.\\n                    value={element.value as number}\\n                />\\n                {/* \\n                    The element wasn\'t guaranteed to re-render, \\n                    so this UI may not update immediately.\\n                    `element.value` will be `undefined` initially\\n                    until set the first time.\\n                */}\\n                <span>{element.value}</span>\\n            </div>\\n        );\\n    }\\n}\\n\\n/**\\n * @displayName Register RangeSlider Form Element\\n * @description Displays a number range slider.\\n * @param props The props that will be provided by the Workflow runtime.\\n */\\nexport class RegisterRangeSliderElement extends RegisterCustomFormElementBase {\\n    execute(): void {\\n        this.register(\\"RangeSlider\\", RangeSlider);\\n    }\\n}\\n```\\n\\n#### After\\n\\nHere\'s the same element but also including configurable `max`, `min`, and `step` properties.\\n\\n```tsx\\nimport * as React from \\"react\\";\\nimport {\\n    FormElementProps,\\n    FormElementRegistration,\\n} from \\"@geocortex/workflow/runtime\\";\\n\\ninterface RangeSliderProps extends FormElementProps<number> {\\n    max: number;\\n    min: number;\\n    step: number;\\n}\\n\\n/**\\n * @displayName Range Slider\\n * @description Displays a number range slider.\\n * @param props The props that will be provided by the Workflow runtime.\\n */\\nfunction RangeSlider(props: RangeSliderProps): React.ReactElement {\\n    const { max, min, setValue, step, value } = props;\\n    return (\\n        <div>\\n            <input\\n                max={max}\\n                min={min}\\n                onChange={(event) =>\\n                    setValue(event.currentTarget.valueAsNumber)\\n                }\\n                step={step}\\n                type=\\"range\\"\\n                value={value}\\n            />\\n            <span>{value}</span>\\n        </div>\\n    );\\n}\\n\\nconst RangeSliderElementRegistration: FormElementRegistration<RangeSliderProps> =\\n    {\\n        component: RangeSlider,\\n        getInitialProperties: () => ({\\n            max: 100,\\n            min: 0,\\n            step: 5,\\n            value: 50,\\n        }),\\n        id: \\"RangeSlider\\",\\n        onPropertyChange: ({ properties, property }) => {\\n            if (\\n                property === \\"max\\" ||\\n                property === \\"min\\" ||\\n                property === \\"step\\" ||\\n                property === \\"value\\"\\n            ) {\\n                const value = properties[property];\\n\\n                // Ensure we always have the type we expect assigned to the element\\n                // properties.\\n                if (\\n                    typeof value !== \\"number\\" ||\\n                    Number.isNaN(value)\\n                ) {\\n                    throw new Error(\\"Unexpected type\\");\\n                }\\n            }\\n        },\\n    };\\n\\nexport default RangeSliderElementRegistration;\\n```"}]}')}}]);