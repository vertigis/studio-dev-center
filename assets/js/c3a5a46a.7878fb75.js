"use strict";(globalThis.webpackChunkvertigis_studio_dev_center=globalThis.webpackChunkvertigis_studio_dev_center||[]).push([[1807],{1895:(e,n,o)=>{o.r(n),o.d(n,{assets:()=>i,contentTitle:()=>c,default:()=>l,frontMatter:()=>s,metadata:()=>d,toc:()=>a});var t=o(4848),r=o(8453);const s={title:"Component Hooks",description:"VertiGIS Studio Web - Learn about the React hooks used to react to changes on a component's model"},c=void 0,d={id:"web/sdk-components-hooks",title:"Component Hooks",description:"VertiGIS Studio Web - Learn about the React hooks used to react to changes on a component's model",source:"@site/docs/web/sdk-components-hooks.mdx",sourceDirName:"web",slug:"/web/sdk-components-hooks",permalink:"/docs/web/sdk-components-hooks",draft:!1,unlisted:!1,editUrl:"https://github.com/vertigis/studio-dev-center/edit/master/docs/web/sdk-components-hooks.mdx",tags:[],version:"current",frontMatter:{title:"Component Hooks",description:"VertiGIS Studio Web - Learn about the React hooks used to react to changes on a component's model"},sidebar:"web",previous:{title:"Component Reference",permalink:"/docs/web/sdk-components-reference"},next:{title:"UIContext",permalink:"/docs/web/sdk-components-ui-context"}},i={},a=[{value:"<code>useWatchAndRerender</code>",id:"usewatchandrerender",level:2},{value:"The Problem",id:"the-problem",level:3},{value:"The Solution",id:"the-solution",level:3},{value:"<code>useWatchCollectionAndRerender</code>",id:"usewatchcollectionandrerender",level:2},{value:"<code>useWatch</code>",id:"usewatch",level:2},{value:"<code>useSubscribeAndRerender</code>",id:"usesubscribeandrerender",level:2},{value:"<code>useSubscribe</code>",id:"usesubscribe",level:2}];function h(e){const n={a:"a",code:"code",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(n.p,{children:["VertiGIS Studio Web provides a number of ",(0,t.jsx)(n.a,{href:"https://reactjs.org/docs/hooks-intro.html",children:"React hooks"})," to ease development of custom components bound to ",(0,t.jsx)(n.a,{href:"/docs/web/sdk-components-reference#models",children:"models"}),". These hooks make it simple to follow the recommended ",(0,t.jsx)(n.a,{href:"https://developers.arcgis.com/javascript/latest/guide/programming-patterns/#properties",children:"observable properties pattern"})," for model interactions within your functional components."]}),"\n",(0,t.jsx)(n.h2,{id:"usewatchandrerender",children:(0,t.jsx)(n.code,{children:"useWatchAndRerender"})}),"\n",(0,t.jsx)(n.p,{children:"Watches an object for changes in one or more properties of a component model and triggers a re-render of the component."}),"\n",(0,t.jsx)(n.h3,{id:"the-problem",children:"The Problem"}),"\n",(0,t.jsxs)(n.p,{children:["In VertiGIS Studio Web, ",(0,t.jsx)(n.a,{href:"/docs/web/sdk-components-reference#models",children:"component models"})," provide a way to decouple components from data source concerns and app interactions. However, they raise the issue of consistency - how can a component stay up to date with changes in the data of the underlying model? E.g. how does the React component know when to re-render?"]}),"\n",(0,t.jsx)(n.h3,{id:"the-solution",children:"The Solution"}),"\n",(0,t.jsxs)(n.p,{children:["VertiGIS Studio Web components solve this problem by providing a way to update the UI when the data in the underlying model changes using a React hook called ",(0,t.jsx)(n.code,{children:"useWatchAndRerender"}),". The component render lifecycle is as follows:"]}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"The initial data is pulled from the model and rendered."}),"\n",(0,t.jsxs)(n.li,{children:["The component ",(0,t.jsx)(n.strong,{children:"starts to watch for changes"})," to the specified properties on the model by using the ",(0,t.jsx)(n.code,{children:"useWatchAndRerender"})," React hook."]}),"\n",(0,t.jsx)(n.li,{children:"The value of the watched property in the model changes. In the example below it changes as a result of a button click."}),"\n",(0,t.jsx)(n.li,{children:"The hook that is watching the property value for changes causes the component to re-render with the new property value."}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-tsx",children:'import { useWatchAndRerender } from "@vertigis/web/ui";\nimport Typography from "@vertigis/web/ui/Typography";\nimport React from "react";\nimport { LayoutElement } from "@vertigis/web/components";\nimport Button from "@vertigis/web/ui/Button";\n\nexport default function CustomComponent(props) {\n    const { model } = props;\n\n    // Start watching for changes to the hidden property on the model\n    useWatchAndRerender(model, "hidden");\n\n    return (\n        <LayoutElement {...props}>\n            {/* Change the underlying model to trigger a re-render */}\n            {model.hidden && (\n                <Button onClick={() => (model.hidden = false)}>\n                    Show Me\n                </Button>\n            )}\n            {!model.hidden && (\n                <div>\n                    <Typography variant="h1">BOO!</Typography>\n                    <Button onClick={() => (model.hidden = true)}>\n                        Hide Me\n                    </Button>\n                </div>\n            )}\n        </LayoutElement>\n    );\n}\n'})}),"\n",(0,t.jsxs)(n.p,{children:['The role of the "watch" functions for a component with respect to model data is similar to the role of the ',(0,t.jsxs)(n.a,{href:"https://reactjs.org/docs/hooks-state.html",children:[(0,t.jsx)(n.code,{children:"useState"})," and ",(0,t.jsx)(n.code,{children:"useEffect"})," functions"]})," with respect to the local state data. The ",(0,t.jsx)(n.code,{children:"useWatchAndRenderer"})," function essentially defines a model property as state your component's presentation is dependent upon, much like ",(0,t.jsx)(n.code,{children:"useState"}),", while leaving you the responsibility to update the underlying component when appropriate. The ",(0,t.jsx)(n.code,{children:"useWatch"})," function defines a dependency on a model property, while leaving you to define what side effects are required, much like ",(0,t.jsx)(n.code,{children:"useEffect"}),"."]}),"\n",(0,t.jsx)(n.h2,{id:"usewatchcollectionandrerender",children:(0,t.jsx)(n.code,{children:"useWatchCollectionAndRerender"})}),"\n",(0,t.jsxs)(n.p,{children:["Watches a collection for change events and triggers a re-render. Conceptually equivalent to ",(0,t.jsx)(n.a,{href:"#usewatchandrerender",children:(0,t.jsx)(n.code,{children:"useWatchAndRerender"})})," but specifically for ",(0,t.jsx)(n.a,{href:"https://developers.arcgis.com/javascript/latest/api-reference/esri-core-Collection.html",children:"Collection objects"}),"."]}),"\n",(0,t.jsx)(n.h2,{id:"usewatch",children:(0,t.jsx)(n.code,{children:"useWatch"})}),"\n",(0,t.jsx)(n.p,{children:"Watches an object for changes in one or more properties and triggers a callback."}),"\n",(0,t.jsx)(n.h2,{id:"usesubscribeandrerender",children:(0,t.jsx)(n.code,{children:"useSubscribeAndRerender"})}),"\n",(0,t.jsxs)(n.p,{children:["Subscribes ",(0,t.jsx)(n.a,{href:"/docs/web/sdk-events-overview",children:"to an event"})," and triggers a re-render."]}),"\n",(0,t.jsx)(n.h2,{id:"usesubscribe",children:(0,t.jsx)(n.code,{children:"useSubscribe"})}),"\n",(0,t.jsxs)(n.p,{children:["Subscribes ",(0,t.jsx)(n.a,{href:"/docs/web/sdk-events-overview",children:"to an event"})," and triggers a callback."]})]})}function l(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(h,{...e})}):h(e)}},8453:(e,n,o)=>{o.d(n,{R:()=>c,x:()=>d});var t=o(6540);const r={},s=t.createContext(r);function c(e){const n=t.useContext(s);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:c(e.components),t.createElement(s.Provider,{value:n},e.children)}}}]);