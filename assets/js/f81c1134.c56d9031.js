"use strict";(globalThis.webpackChunkvertigis_studio_dev_center=globalThis.webpackChunkvertigis_studio_dev_center||[]).push([[8130],{7735:e=>{e.exports=JSON.parse('{"archive":{"blogPosts":[{"id":"/2025/08/05/web-observable-overhaul","metadata":{"permalink":"/blog/2025/08/05/web-observable-overhaul","source":"@site/blog/2025-08-05-web-observable-overhaul.mdx","title":"VertiGIS Studio Web 5.37 Observable Overhaul","description":"The recent deprecation of the .watch method in the ArcGIS Maps SDK for JavaScript caused a cascade effect on key underlying property observability behavior in VertiGIS Studio Web.","date":"2025-08-05T00:00:00.000Z","tags":[{"inline":true,"label":"web","permalink":"/blog/tags/web"},{"inline":true,"label":"sdk","permalink":"/blog/tags/sdk"}],"readingTime":40.06,"hasTruncateMarker":true,"authors":[{"name":"Brenda Parker","title":"Software Developer","url":"https://github.com/bparker-dev","imageURL":"https://github.com/bparker-dev.png","key":null,"page":null}],"frontMatter":{"title":"VertiGIS Studio Web 5.37 Observable Overhaul","author":"Brenda Parker","authorTitle":"Software Developer","authorURL":"https://github.com/bparker-dev","authorImageURL":"https://github.com/bparker-dev.png","tags":["web","sdk"]},"unlisted":false,"nextItem":{"title":"Using AI Image Recognition with the VertiGIS Studio Mobile SDK","permalink":"/blog/2025/06/04/mobile-sdk-ai-image-recognition"}},"content":"The recent deprecation of the `.watch` method in the ArcGIS Maps SDK for JavaScript caused a cascade effect on key underlying property observability behavior in VertiGIS Studio Web.\\nThis blog post is the fully story of how this one change caused us to rethink property observability and what changes can be expected with VertiGIS Studio Web 5.37.\\n\\n\x3c!--truncate--\x3e\\n\\n:::note\\nIf you want to know what the end result is and what the new functionality and interfaces look like, jump to the last section [The New Watch System](2025-08-05-web-observable-overhaul.mdx#the-new-watch-system). If you\u2019re curious about why we did this and how we got to the end result, read on.\\n:::\\n\\n## ArcGIS Maps SDK for JavaScript `.watch` Deprecation\\n\\nPrior to the ArcGIS Maps SDK for JavaScript (ArcGIS JS SDK) version 4.32 release, almost every class in the ArcGIS JS SDK had a `.watch` method. This method was inherited from the base class `Accessor` that most classes in the ArcGIS JS SDK ultimately inherit from. With the release of 4.32, the `.watch` method on `Accessor` was deprecated in favour of using their `reactiveUtils` utility functions instead as these were the utilities that replaced the `watchUtils` the ArcGIS JS SDK had at initial release.\\n\\nWhen VertiGIS Studio Web (Web) was first developed, we followed the watch pattern that had been established by the ArcGIS JS SDK. Doing this allowed for a more seamless experience when developing Web SDK applications; you could follow the same pattern and the watch utilities were compatible.\\n\\nWhen `watchUtils` was deprecated and `reactiveUtils` support was added, we had to make a decision of how we would support this change going forward. Because only `watchUtils` support was being removed, and the `.watch` method on `Accessor` was remaining, it was decided to leave the `.watch` method on our classes as well but also add support for using our classes with `reactiveUtils`. By doing this we were able to support `reactiveUtils` without any breaking changes to our APIs. You can read about the `watchUtils` to `reactiveUtils` change in the ArcGIS JS SDK here: [Why you should be using reactiveUtils instead of watchUtils](https://www.esri.com/arcgis-blog/products/js-api-arcgis/developers/reactiveUtils-and-why-you-should-be-using-them-instead-of-watchutils-with-the-arcgis-maps-sdk-for-javascript).\\n\\nNow, with the deprecation of the `.watch` method on `Accessor`, the last vestige of the `watchUtils` is finally being removed from the ArcGIS JS SDK. But as much of our code still uses the `.watch` method pattern, we finally had to confront a breaking change.\\n\\n## How the Removal of One Method Snowballed into an Overhaul\\n\\nWhy not just remove the one deprecated pattern and leave the `reactiveUtils` support? Good question. That was definitely an option. But the support for `reactiveUtils` and how it was implemented had some major side effects that we\u2019ve been trying to deal with ever since.\\n\\n### `reactiveUtils` Inside VertiGIS Studio Web\\n\\nTo understand why the deprecation of `.watch` cascaded into an overhaul of our property watch system, you have to understand how we\u2019re currently supporting the use of our classes with the ArcGIS JS SDK\u2019s `reactiveUtils` and how `reactiveUtils` work.\\n\\nAll of the ArcGIS JS SDK\u2019s classes (or at least most) are compatible with `reactiveUtils`; you can use them with `reactiveUtils` without thinking about it and it will just work. However, if you try to use your own class with `reactiveUtils` it isn\u2019t going to do anything.\\n\\nFor properties to be \\"watchable\\" with `reactiveUtils`, your property needs to be able to \\"announce\\" itself to the ArcGIS JS SDK `reactiveUtils` system whenever it is accessed, not just when it changes. To do this you would normally need to add a decorator the ArcGIS JS SDK provides to your property (See [Property](https://developers.arcgis.com/javascript/latest/api-reference/esri-core-accessorSupport-decorators.html#property)). This decorator adds the necessary code to the property to make the property \\"watchable\\".\\nHaving to add this decorator to every property in Web would have been a daunting task, but that wasn\u2019t the only problem we faced.\\n\\nAt the time, to use those decorators you needed to set your `tsconfig` with `useDefineForClassFields` to `false`. Setting this to `false` is only meant for pre-TC39 projects as part of migration and this compiler option now defaults to true since ES2022 when not specified. We did not like the idea of using an old compiler option to use `reactiveUtils` with our classes.\\n\\nSo if we didn\'t want to find every single property in our classes to decorate and we didn\'t want to use the old compiler option, we needed another solution. Enter, the [JS Proxy](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy)... and some dicey JS.\\n\\nIf we could wrap our classes in a JS Proxy we would be able to use its traps for \u2018get\u2019 and \u2018set\u2019 which would give us the ability to \\"announce\\" access and changes of a property to the underlying system supporting `reactiveUtils`. We already had a core base class called `Observable` that was handling the old `watchUtils` style watches and all classes in Web ultimately inherited from this base class, so the proxy was added to the constructor of this class.\\n\\nNow, the classes and interfaces necessary to be able to tell `reactiveUtils` about properties are not exposed publicly from the ArcGIS JS SDK, but being JS everything is technically accessible. We did some reverse engineering to discover how to tell `reactiveUtils` when a property was accessed or changed and implemented that in the proxy traps. This effectively allowed every property on all of our classes to participate in the `reactiveUtils` watch system.\\n\\n### The Downsides of Using JS Proxy with Classes in Web\\n\\nFor the most part, the JS Proxy implementation has been very effective. So effective, in fact, that it seems to be doing magic, and that magic has created some very hard to find bugs over the years.\\n\\nBecause the JS Proxy traps all properties on the object, this means that all data properties, accessor properties, and **methods** must run through the \u2018get\u2019 and \u2018set\u2019 traps. Additionally, every time an accessor property was accessed (getter), every single underlying property and method that was on one of our classes that was invoked in the property getter would announce itself to the `reactiveUtils` watch system. This cascade of property tracking made it easy to create a new property without needing to worry about the watch system and what it needs to know about to watch that property for changes. However, this amount of magic is costly, and performance takes a significant hit for this convenience. Memory usage also suffers with the amount of extra things being tracked that don\u2019t necessarily need to be. On top of this, because this was implemented in the base class that everything in Web inherits from, it made everything in Web watchable, even when it didn\u2019t need to be, creating even more overhead.\\n\\nThere are other development level inconveniences. The amount of \\"magic\\" happening for watches meant that when the \\"magic\\" didn\u2019t work, developers would spend an inordinate amount of time trying to figure out why, instead of understanding the limitations of the watch system and when they needed to perform some extra calls to ensure that watches would work properly. It would even result in some interesting workarounds to what should have been a simple fix. Using the proxy also made it so that JS\u2019s private property `#prop` couldn\u2019t be used as these properties are not available on JS Proxies, limiting use of a built-in modern JS feature in our codebase. The main inconvenience though, is during debugging. JS Proxies add an extra layer to objects to sift through when trying to debug your code, and if every single class is a proxy, that\u2019s a lot of extra layers to go through to get to the information you\u2019re looking for, subsequently burning development time.\\n\\nWith these issues in mind, particularly the performance hit, we\u2019ve been wanting to remove the use of the JS Proxy from our classes for some time, but we\u2019ve never had a good path forward that would allow us to continue providing property change watch support with `reactiveUtils`.\\n\\n### The Pros and Cons of `reactiveUtils`\\n\\nOver the years we have seen many uses of `reactiveUtils`, both in our codebase and across various Web SDK applications built internally and externally, and we have learned a lot about how to use it well, where it shines, and where we wish we had something slightly different.\\n\\nLet\u2019s talk about the pros. The interface is simple and somewhat familiar to JS developers. Callbacks are commonplace in JS and by utilizing them for the watch value callback the `watch` function from `reactiveUtils` is easy to use. Autocomplete and renaming properties/methods work well in IDEs and there\u2019s flexibility, allowing you to do more than just return a property value: you can return calculations from multiple properties and all of that would be tracked and trigger the callback when those properties change. If using TypeScript, as we recommend and use in our codebase, the return value from the watch value callback is typed properly when passed to the callback, making development that much easier and less error prone.\\n\\nBut there are some downsides we\u2019ve found, and some are harder to spot than others.\\nThe first issue that caught us quite a few times is that the property you are watching, the entire object chain, may not actually be watchable and there\u2019s nothing in the IDE, types from TypeScript, or even at runtime that will tell you that the watch you setup isn\u2019t going to do anything.\\n\\nThe callback in this code will never execute:\\n\\n```ts\\nconst myObj = { testProp = \\"test1\\" };\\nwatch(\\n    () => myObj.testProp,\\n    // This callback will never fire because the\\n    // object being watched isn\'t watchable.\\n    (value) => console.log(value)\\n);\\nmyObj.testProp = \\"test2\\";\\n```\\n\\nWhile this is a contrived example, it is easy to see where someone can accidentally fall into this trap when you\u2019re working with many nested properties on a mix of objects from different sources. There have been a number of times where a watch would be added that looks like it is needed and everything seems to be working as intended but the watch itself never actually does anything because it is watching something that is unwatchable and the intended behavior is actually occurring due to another piece of code. While having a watch that does nothing may not seem so bad on the surface, it does clutter up code and change people\u2019s expectations of how something is supposed to be working. There is also another drawback we discovered.\\n\\nCreating a new watch does impact performance. When you spend a minute to think about it, of course it does! You\u2019re executing a function that is going to do something, it must do work which takes some amount of time. But it isn\u2019t always something that is considered; executing code to setup something that will ultimately never perform the action it is supposed to is, of course, going to impact performance. With watch from `reactiveUtils` not being able to tell us if the thing we\u2019re watching is actually watchable, we could be adding a small performance hit to something and if that small performance hit happens 100,000 times, well... you get the idea.\\n\\nAnother thing we\'ve noticed was a recurring misuse of `watch` from `reactiveUtils`. `watch` will return a handle that is supposed to be called to cleanup the watch when it is no longer needed. While this pattern of cleaning up a handler (or listener) is extremely prevalent in development, we\u2019ve found that this is easily missed with `reactiveUtils` use, and have been known to miss it ourselves from time to time, causing memory leaks.\\n\\nThere is one more consideration that is easily missed when constructing watches using `reactiveUtils`, and to understand this, you need to know how JavaScript closures and lexical scoping work.\\n\\nLet\u2019s take the following code as an example:\\n\\n```ts\\nfunction myLeakyFunc(\\n    someLargeObject: object,\\n    someObservableObject: object\\n) {\\n    // The lexical scope created at this level\\n    // includes both `someLargeObject` and `someObservableObject`.\\n\\n    // This lexical scope is captured by all 3 anonymous\\n    // functions\' closures and will live for as long as the\\n    // anonymous functions are referenced.\\n\\n    const myFunc = () => {\\n        console.log(someLargeObject);\\n    };\\n\\n    const handle = watch(\\n        () => someObservableObject.prop,\\n        (newPropValue) => console.log(newPropValue)\\n    );\\n\\n    return [myFunc, handle];\\n}\\n```\\n\\nOn the surface this seems innocent enough. We have a large object that needs to be used in an anonymous function and a watch that needs to watch a property on a completely separate observable object, and the anonymous function is returned for use by the caller as well as the watch handle for cleanup when no longer needed. But sadly this has the potential to create a whole host of memory leaks depending on the browser engine and garbage collector being used.\\n\\nWhen JavaScript creates closures for functions, those closures are created using the lexical environment for where that function is created. When functions exist at the same lexical environment level, they share the same lexical scope. In this case, both `myFunc`, the watch value callback, and the watch callback all share the same lexical scope. This means that any objects that are needed for one of these anonymous functions are included in the closure for the other functions, even though they don\u2019t use the value. This means that, even if the returned `myFunc` goes out of scope by the running program and is cleaned up by the GC, the watch is still holding onto the large object because the large object was included in the lexical scope that the watch callbacks\u2019 closures captured. This also happens the other way around, where `myFunc` will hold the observable object alive even when we cleanup the watch by calling `remove` on the returned handle when we were done with it.\\n\\nWhile this last example is a basic one, it is easy to imagine how quickly these closure leaks can become a problem in modern JavaScript development.\\n\\n### So, Back to the Removal of `.watch`\\n\\nWith the removal of `.watch` from the ArcGIS JS SDK classes it makes sense for us to remove our implementation of `.watch` as well, given that our `.watch` is tied into the ArcGIS JS SDK implementation. This would be a breaking change in the Web SDK which we do try to approach with much caution. While the removal of `.watch` from the ArcGIS JS SDK is going to be a breaking change for Web SDK developers, and there isn\u2019t anything we can do about that, we always look carefully at any breaking changes we\u2019re going to make to our APIs to ensure that they are truly in the best interests of progressing the ease of future development.\\n\\nRemoving `.watch` would leave us relying on `reactiveUtils` for observable functionality, and as you\u2019ve seen reading through this, perhaps that isn\u2019t the best approach for Web, with the use of the JS Proxy and various performance and memory issues. After much discussion, since we were going to have to make a breaking change to the Web SDK anyway with the removal of `.watch`, we decided to look into what it might look like if we revisited property observability with a fresh approach.\\n\\n## Shaping the New Watch System\\n\\n### The Wish List\\n\\nWe compiled a wish list of everything we would want in a property observability implementation, knowing that we likely would need to compromise in some places.\\n\\n1. Does not use a JS Proxy.\\n2. A watch system that would remain stable with the same interface if the ArcGIS JS SDK ever changes their watch system again.\\n3. Will error at compile time with TypeScript if given objects or properties that cannot be watched.\\n4. Will error or warn at runtime if trying to watch objects or properties that cannot be watched.\\n5. Will not leak memory, even when misused.\\n6. Will not do anything functional when nothing is watching a property that is watchable. i.e.: no tracking announcements, no change notifications to nowhere, etc.\\n7. Will provide auto-completions with TypeScript for properties that are watchable.\\n8. Will provide correct types with TypeScript for values passed to any callbacks.\\n9. Remove the need for a root base class that everything must inherit from so that we can be selective about classes that can be observable, not everything needs to be watched.\\n10. Does not use private/internal code from a third-party library or the ArcGIS JS SDK.\\n11. Does not require any form of specifying the exact properties that will be observable when creating a new class or updating an existing one.\\n12. Observability must be opted into by the class implementor.\\n13. Can accept objects from the ArcGIS JS SDK that are watchable.\\n\\nAnd as a must have: Allows us to provide a smooth transition for Web SDK apps with full backwards compatibility for, at minimum, a couple of full release cycles.\\n\\nThis seemed like a pretty daunting wish list. But we had a few ideas, and JavaScript is inherently extremely flexible.\\n\\n### `reactiveUtils` Support \u2013 Or Lack Thereof\\n\\nThere was one thing that stood out to us with our wish list though; we would not be able to support using our classes with the ArcGIS JS SDK\u2019s `reactiveUtils` with any new system we came up with that lacked a JS Proxy. `reactiveUtils` inherently requires the running of property access tracking code when you have no idea if something is watching a property or not, which conflicts with wish list item #6 (no extra code execution). And even if we could come up with something, we\u2019d still end up breaking wish list item #1 (no JS Proxy) and #10 (no third-party private code use). Wish list item #5 (no memory leaks) would also continue to be an issue, and there would be the threat of wish list item #2 (stable interface) not being met.\\n\\nBecause of these reasons, we decided to proceed with a proof-of-concept (POC) that would not include support for using our classes with `reactiveUtils` functions. We would work in support after if the POC was viable for backwards compatibility, but if the implementation made it past POC the expectation to be set was that support for `reactiveUtils` would be removed.\\n\\n### Typing the New Watch Function\\n\\nA number of our wish list items are related to TypeScript and typing watch functionality so we can surface mistakes at compile time and in an IDE well before code tries to run.\\n\\nThe `reactiveUtils` pattern does get part way there, but as we\u2019ve explored, it won\u2019t tell you if you\u2019re watching something that shouldn\u2019t be watched because there is no way to interrogate the objects being used in the watch value callback. To compound the type issues with the `reactiveUtils` watch pattern, we were also thinking about how to deal with accidental/misuse caused memory leaks. We knew we were going to have to have some form of callback for the watch property value change, but if we could control how the property value is accessed before executing that callback and wrap the main object reference in a `WeakRef`, we\u2019d be able to manage the watch\u2019s object references in a more efficient and less prone to leaks way.\\n\\nWith these things in mind, we decided that our best option was to create a utility function, separate from any classes and require the object to be watched to be passed to it, which will allow us to control how the watch system holds a reference to that watched object.\\n\\nThe original `.watch` functions used a string to specify paths to properties, but it was just a string, causing mistypes and refactors to break watches without anything surfacing the issue in a timely manner. Those `.watch` functions were written quite awhile ago, when TypeScript wasn\u2019t very good at recursive typing, and template string types didn\u2019t exist.\\n\\nSo, along with the object to be watched we decided a string property path would be our best option. With modern TypeScript, we can now build out a complex, template string recursive type that can build out the available watch options for nested watch property paths. There is a bit of a performance hit in IDEs when this recursive type encounters large deeply nested objects, so after dialing in the type performance we had to limit the depth of recursion to three for full type checking. But we expect that with the new [native TypeScript](https://devblogs.microsoft.com/typescript/typescript-native-port/) compiler that\u2019s in the works, this performance issue will get much better and we will likely be able to expand the depth of the type checking further.\\n\\nAside from the minor IDE performance issue, there is another IDE related drawback to the string property path: you won\u2019t be able to use rename functionality and have that update the string references, nor will a reference lookup find watches for the properties being watched. But we decided these IDE drawbacks can be lived with, given the memory management advantage of this pattern.\\n\\nAfter dialing in the types and starting to spread around the new watch, we did encounter one other quirk. When attempting to pass `this` as the object being watched, TypeScript wasn\u2019t happy. Turns out, when you\u2019re using constrained generic types for typing arguments and you pass `this` to one of those arguments TypeScript won\u2019t infer the type of `this`. They have their reasons, but it is a bit inconvenient in our use case. We debated on how to handle this, and tried a number of different ways to workaround it, but in the end we couldn\u2019t find anything better than just casting `this` when passed. But, we also realized that in a lot of cases we see where `this` is being passed as the watch object, a watch really shouldn\u2019t be used. Using the watch system to know when a property changes that you have control of is pretty heavy handed; a better approach would be to do whatever action you want in a setter instead.\\n\\n### No Base Class? Let\u2019s try Decorators \u2026 (spoiler, we didn\u2019t use decorators)\\n\\nWish list #9 would have us remove the `Observable` base class from all of our classes so that we can be more targeted about what is actually observable and what is not. To do this we would need some way to add functionality to a class without inheritance. This sounds like exactly what decorators are designed to do.\\nThe first iteration of the new observable implementation was built as a class decorator. This would fulfill wish list item #9 and #11 (no base class and not specifying exact properties that are observable, respectively).\\n\\nHowever, we ran into some immediate problems around TypeScript typing. Mainly, TypeScript doesn\u2019t augment the types of a class (or anything) that uses a decorator that, from the JavaScript perspective, does augment the class with new functionality. This created a typing problem: to satisfy wish list item #12 (opt in observability) we would need an extra interface that implementors would also have to add to their observable classes to ensure that the class is observable. It looked something like this:\\n\\n```ts\\ninterface IObservable {\\n    __isObservable: true;\\n}\\n```\\n\\nNow, having to spread that around everywhere whenever you used the decorator was going to be very annoying. So, we decided that perhaps, at this moment in time, decorators were not the answer to our problem.\\n\\n### Enter the Mixin Pattern\\n\\nDecorators are really just a another way of using the mixin pattern, so we switched gears and gave that a try instead, and it ended up working out really well. With the mixin pattern we were able to wrap any class with our observable implementation, even base classes that a class is inheriting from. It also allowed us to type the returned class so TypeScript would understand that this class is observable so we could surface the type errors we were hoping to without needing to expose an extra interface.\\n\\nThis still requires using the mixin as a base class in most use cases, but because it is a mixin, you can use it to wrap a base class you are already inheriting from, effectively allowing multiple inheritance. While it doesn\u2019t get rid of the base class requirement if the mixin is used this way, it does get rid of the problem that we were trying to solve when we wished for the watch system to not use a base class.\\n\\nAs with everything, there is one drawback to this pattern. If you have constructed a class hierarchy that requires a generic type be passed from a child class to a parent class, TypeScript will not be happy with that.\\n\\nAfter reviewing this issue, it was decided this was an acceptable drawback. In most cases, there are other ways to workaround this using base types or type overrides in the child class and this situation does not occur commonly in our Web SDK patterns.\\n\\n### How do you Watch a Property for Changes Without a JS Proxy?\\n\\nA JS Proxy has its uses, and observability is one of them, but we\u2019ve found that in Web it just doesn\u2019t scale well. Then the question became, how do you watch a property for changes while satisfying wish list item #11 and not requiring developers to specify every single property they want to be able to watch?\\n\\nLooking at this problem at the very basic level, we want to be able to call a function (the watch callback) whenever a property is set to a new value. If doing this for just one class, you\u2019d likely consider adding a call to property setters. This thought is what lead us to our implementation.\\n\\nJavaScript objects allow you to redefine property descriptors so long as the descriptor is configurable. Since all of the objects we work with have configurable descriptors we realized that we could redefine the properties on demand to augment their setter (or if they don\u2019t have one add a setter) to include code to handle calling watch callbacks when the property value changes. A quick POC of this proved its viability. This admittedly may seem a little hacky, but if done thoughtfully and carefully we would be able to create a watch system that only ever does work if something creates a watch instead of having to assume there might be a watch.\\n\\nClasses from the ArcGIS JS SDK are a bit different. We felt that since it already has a watch system (`reactiveUtils`) and all the underlying code of that system would be run anyway, we might as well defer to it when we encounter an ArcGIS JS SDK object that is watchable. By controlling how `reactiveUtils` is used with ArcGIS JS SDK objects under the hood of the new watch system, we can control when a watch needs to be created and manage the accessed objects with `WeakRef`s for better memory management.\\n\\n### Backwards Compatibility and the Consequences\\n\\nAt this point we had a pretty good looking POC, everything in our codebase was swapped over and all was well with our automated tests and initial basic testing. But there would be no way we could release this as is as it would break almost every single Web SDK built app out there. We had to come up with a plan for a non-breaking transition.\\n\\nDeprecating the old `.watch` functions on our classes instead of removing them outright and swapping the underlying code to the new watch system was fairly straightforward. We just had to change some places where we were throwing exceptions in our new code to log warnings instead and add some extra null checks. We deprecated some other utility functions as well in favour of the new observable system functions.\\n\\nThe real challenge was going to be `reactiveUtils` support. We ran through a number of different ways to try to add it into the new system without using a JS Proxy, but nothing was going to work 100% of the time. We had to add the proxy back\u2026 This meant that some of our innovations for better memory management and improved performance would not be able to make the first release of the new observable system, but backwards compatibility was non-negotiable.\\n\\n### If You\u2019ve Been Keeping Score\\n\\nIf we look through our wish list items, it looks like we managed to tick everything off the list! Well, almost\u2026 the improved memory management and performance will have to wait until we can remove the support added for backwards compatibility and `reactiveUtils`. We\u2019ll also need to wait for the native TypeScript compiler to dial in the type checking even further. We also didn\u2019t fully get rid of a base class, but we did solve the problem that wish list item was for with the mixin pattern allowing for multiple inheritance. But overall, we managed to accomplish what we set out to do.\\n\\n## The New Watch System\\n\\nWe\u2019ve completely overhauled how watching objects for property changes works in the VertiGIS Studio Web SDK (Web SDK). This new functionality is going to be more performant and use less memory than the previous versions (once the old code and support for backwards compatibility is removed) and will create a stable interface for us to continuously improve and add to the property watch system.\\n\\nThis new system will reduce the number of common errors we see when using the currently available property watch systems. We did have to deprecate a number of things from the old systems that will be removed, so make sure to review the list and update your Web SDK apps soon. While we are giving a transition period of a couple full release cycles, it is better to jump on this change sooner rather than later.\\n\\n### New Module: observableUtils\\n\\nWe\u2019ve added a new module that contains all of the new observable functionality called `observableUtils`.\\n\\nYou can import `observableUtils` functions from @vertigis/arcgis-extensions.\\n\\n```ts\\nimport { watch } from \\"@vertigis/arcgis-extensions/support/observableUtils\\";\\n```\\n\\n<table>\\n    <tr>\\n        <th>Function</th>\\n        <th>Description</th>\\n    </tr>\\n    <tr>\\n        <td>`observable`</td>\\n        <td>The mixin used to add observability to a class.</td>\\n    </tr>\\n    <tr>\\n        <td>`watch`</td>\\n        <td>\\n            Watches a specific property or property path for changes.\\n        </td>\\n    </tr>\\n    <tr>\\n        <td>`notifyChange`</td>\\n        <td>\\n            Tells the watch system that the given property may have\\n            changed and needs to be checked.\\n        </td>\\n    </tr>\\n    <tr>\\n        <td>`onWatch`</td>\\n        <td>Allows you to react to something watching a property.</td>\\n    </tr>\\n    <tr>\\n        <td>`watchEach`</td>\\n        <td>Watches a property on each item in a collection.</td>\\n    </tr>\\n    <tr>\\n        <td>`watchEvent`</td>\\n        <td>\\n            Attaches an event listener to the watched property and\\n            removes the old listener whenever the property changes.\\n        </td>\\n    </tr>\\n    <tr>\\n        <td>`once`</td>\\n        <td>\\n            Async watch that allows you to await for a property to\\n            change.\\n        </td>\\n    </tr>\\n    <tr>\\n        <td>`when`</td>\\n        <td>\\n            Watches a property or property path for the value to\\n            become truthy.\\n        </td>\\n    </tr>\\n    <tr>\\n        <td>`whenOnce`</td>\\n        <td>\\n            Async when that allows you to await for a property to\\n            become truthy.\\n        </td>\\n    </tr>\\n    <tr>\\n        <td>`createIHandle`</td>\\n        <td>\\n            Helper utility to create a new IHandle from an iterable of\\n            IHandles.\\n        </td>\\n    </tr>\\n</table>\\n\\n#### Observable Mixin\\n\\nTo add observability to a class there are a few different ways to use the new mixin to accomplish this, but we\u2019ve found the cleanest approach, and the one that gets you the best type checking by TypeScript, is to extend the mixin, or wrap a base class being extended with the mixin.\\n\\n```ts\\nclass MyClassNoBaseClass extends observable() {}\\n\\nclass MyClassWithBaseClass extends observable(BaseClass) {}\\n```\\n\\nThis will make your class observable so it can be used with the other `observableUtils` functions.\\n\\n#### `watch`\\n\\nThis is the main watch function, it is also what backs `useWatch` and most if its variants. This function supports watching any classes from the Web SDK that are observable, any classes from the ArcGIS JS SDK that inherit from Accessor which indicates that they are observable, and any custom classes that you create that use the observable mixin.\\n\\n`watch` watches a property for changes. This can be a property on the given object or a property on a nested object if the nested object is also observable. It will call the given callback whenever the property value for the given path changes. The callback, however, will not be invoked if the value is set to the same value or the value ultimately has not changed. This includes if a parent property in a nested property path changes but the resulting value is the same as the previous value.\\n\\n```ts\\nclass MyObservable extends observable() {\\n    private _backingFieldForGetter = \\"backingFieldForGetter\\";\\n    dataProperty: string = \\"dataProperty\\";\\n\\n    get getter() {\\n      return this._backingFieldForGetter;\\n    }\\n}\\n\\nconst myObservable = new MyObservable();\\nwatch(myObservable, \\"getter\\", callback);\\nwatch(myObservable, \\"dataProperty\\", callback);\\n\\nclass MyClass extends observable() {\\n   private _backingFieldForAccessor = new MyObservable();\\n\\n   get getterSetter {\\n     return this._backingFieldForAccessor;\\n   }\\n   set getterSetter(value: MyObservable) {\\n     this._backingFieldForAccessor = value;\\n   }\\n}\\n\\nconst myClass = new MyClass();\\nwatch(myClass, \\"getterSetter\\", callback);\\nwatch(myClass, \\"getterSetter.getter\\", callback);\\nwatch(myClass, \\"getterSetter.dataProperty\\", callback);\\n```\\n\\n`watch` returns an IHandle that should be removed once the watch is no longer needed.\\n\\n```ts\\nconst handle = watch(myClass, \\"getterSetter\\", callback);\\n// Call remove on the handle when you no longer need the watch.\\nhandle.remove();\\n```\\n\\nThe `watch` function accepts some options to modify its behavior.\\n\\n<table>\\n    <tr>\\n        <th>Option</th>\\n        <th>Description</th>\\n    </tr>\\n    <tr>\\n        <td>`sync`</td>\\n        <td>\\n            Whether or not the callback will be called synchronously.\\n            Default is false.\\n        </td>\\n    </tr>\\n    <tr>\\n        <td>`once`</td>\\n        <td>\\n            If true, the callback will only be called once on the very\\n            first property change. Default is false.\\n        </td>\\n    </tr>\\n    <tr>\\n        <td>`initial`</td>\\n        <td>\\n            If true, the callback will be called with the initial\\n            value of the property. In this case, both the newValue and\\n            oldValue properties will contain the initial value.\\n            Default is false.\\n        </td>\\n    </tr>\\n</table>\\n\\n```ts\\nwatch(myClass, \\"myProp\\", callback, {\\n    sync: true,\\n    initial: true,\\n    once: true,\\n});\\n```\\n\\nIn regards to the `sync` option, it is recommended to avoid using this when possible and instead allow your callback to be invoked async. Reacting to property changes asynchronously gives more room for the JS event loop to continue with other async work including user interactions, creating a better user experience.\\n\\n#### `notifyChange`\\n\\n`notifyChange` allows you to tell the watch system that a property may have changed. When `notifyChange` is called for a property, the watch system will check if the property value has indeed changed, if it has it will trigger the watches for that property as appropriate, else it will do nothing.\\n\\nFor the most part, the watch system handles basic property updates itself without needing `notifyChange` to be called manually. There are some cases though where the watch system cannot determine on its own if the value of a property has changed. It is important to be aware of these cases and handle them properly.\\n\\nThe most common case is when an accessor property\u2019s backing property is updated directly instead of using a setter. It is common to see this with getter only properties. In this scenario, the watch system has no way to know that the backing property was updated, and that the accessor\u2019s value has changed.\\n\\n```ts\\nclass MyClass extends observable() {\\n    private _myBackingProperty: number = 0;\\n\\n    get myProp() {\\n        return this._myBackingProperty;\\n    }\\n\\n    doSomething() {\\n        this._myBackingProperty++;\\n        // We need to announce a change for the prop `myProp`\\n        // because we have updated its backing property.\\n        notifyChange(this, \\"myProp\\");\\n    }\\n}\\n```\\n\\nOther cases where notifyChange needs to be called are similar and usually involve a getter that derives its value from other properties either on the current object, on referenced objects, or from static or global properties.\\n\\n#### `onWatch`\\n\\nSometimes, you need to know when a property is being watched. This is what `onWatch` is for, it calls a callback whenever the specified property on an object starts being watched.\\n\\nThe function came about from a common pattern we saw in our codebase where we would create a watch to call notifyChange on a local property. By wrapping this pattern in this function we\u2019re now able to avoid the overhead of watching a property to call `notifyChange` for another property when no one is actually watching the property we are notifying for.\\n\\n```ts\\nclass MyClass extends observable() {\\n    _foo = \\"foo\\";\\n    _bar = \\"bar\\";\\n    get foo() {\\n        return `${this._foo} ${this._bar}`;\\n    }\\n    get bar() {\\n        return this._bar;\\n    }\\n    set bar(value: string) {\\n        this._bar = value;\\n    }\\n}\\n\\nconst myClass = new MyClass();\\n\\nconst handle = onWatch(myClass, \\"foo\\", () =>\\n    watch(myClass, \\"bar\\", () => notifyChange(myClass, \\"foo\\"), {\\n        // We use sync: true here so the notify is synchronous.\\n        // This ensures that any watches on the property being\\n        // changed can respond sync or async as they are configured.\\n        sync: true,\\n    })\\n);\\n\\n// Call remove on the returned handle when the onWatch is no longer needed.\\nhandle.remove();\\n```\\n\\n`onWatch` expects the callback it is given to return an IHandle, the handle returned by the callback will be called when the property `onWatch` is monitoring is no longer being watched by anything.\\n\\n#### `watchEach`\\n\\nWhen you need to watch for changes on objects in a `Collection`, you can use `watchEach`. `watchEach` allows you to watch a `Collection` or specify a path to a property on an object that contains a `Collection` and watch for changes to a property that exists on the items in the `Collection`.\\n\\n```ts\\nclass MyObservable extends observable() {\\n    property: string = \\"testProperty\\";\\n}\\n\\nclass MyClass extends observable() {\\n    collection: Collection<MyObservable> = new Collection();\\n}\\n\\nconst myClass = new MyClass();\\nconst handle1 = watchEach(\\n    myClass,\\n    \\"collection.[].property\\",\\n    (newValue, oldValue) => {}\\n);\\n\\nconst myCollection = new Collection<MyObservable>();\\nconst handle2 = watchEach(\\n    myCollection,\\n    \\"[].property\\",\\n    (newValue, oldValue) => {}\\n);\\n\\n// Call remove on the returned handle when the watchEach is no longer needed.\\nhandle1.remove();\\nhandle2.remove();\\n```\\n\\nThe `[].` syntax was created to help the watch system determine where the `Collection` starts so it can iterate over the `Collection` to watch the items in it as appropriate.\\n\\n#### `watchEvent`\\n\\nThere are times when you want to subscribe to an event on the value of a property, but that property\u2019s value can change. `watchEvent` is a convenience function that makes handling this case a bit easier than managing the watch and event subscriptions yourself.\\n\\n```ts\\n// The watch callback is optional. It is called when the value of the watched property changes.\\nconst handle = watchEvent(\\n    myObj,\\n    \\"myProp\\",\\n    [\\"change\\", eventCallback],\\n    watchCallback\\n);\\n\\n// Call remove on the returned handle when the `watchEvent` is no longer needed.\\nhandle.remove();\\n```\\n\\n#### `once`\\n\\nThis is a convenience function to make it easier to `await` for a property change if you only need to wait for one change. You can pass an `AbortSignal` to the options to cancel waiting, in which case the returned promise will be aborted.\\n\\n```ts\\nawait once(obj, \\"myProp\\", { signal });\\n```\\n\\n#### `when`\\n\\n`when` allows you to react to a property becoming truthy. (Truthy and falsy are common terms in JavaScript, if unfamiliar see [Truthy](https://developer.mozilla.org/en-US/docs/Glossary/Truthy) and [Falsy](https://developer.mozilla.org/en-US/docs/Glossary/Falsy)). `when` will invoke the given callback whenever the property\u2019s value becomes truthy.\\n\\n```ts\\nclass MyClass extends observable() {\\n    myProp: string | undefined = undefined;\\n}\\n\\nconst obj = new MyClass();\\n\\nconst handle = when(obj, \\"myProp\\", callback);\\n\\n// Setting the property value to a falsy value will not invoke the callback.\\nobj.myProp = \\"\\";\\n\\n// Setting the property value to a truthy value will invoke the callback.\\nobj.myProp = \\"test value\\";\\n\\n// Call remove on the returned handle when the `when` is no longer needed.\\nhandle.remove();\\n```\\n\\nIf the value of the property being watched is already truthy, the callback will be invoked immediately.\\n\\nThe `when` function accepts some options to modify its behavior.\\n\\n<table>\\n    <tr>\\n        <th>Option</th>\\n        <th>Description</th>\\n    </tr>\\n    <tr>\\n        <td>`sync`</td>\\n        <td>\\n            Whether or not the callback will be called synchronously.\\n            Default is false.\\n        </td>\\n    </tr>\\n    <tr>\\n        <td>`once`</td>\\n        <td>\\n            If true, the callback will only be called once on the very\\n            first property change. Default is false.\\n        </td>\\n    </tr>\\n    <tr>\\n        <td>`invert`</td>\\n        <td>\\n            If true, the callback will be called when the property\\n            value becomes falsy. Default is false.\\n        </td>\\n    </tr>\\n</table>\\n\\n```ts\\nwhen(myClass, \\"myProp\\", callback, {\\n    sync: true,\\n    invert: true,\\n    once: true,\\n});\\n```\\n\\nIn regards to the `sync` option, it is recommended to avoid using this when possible and instead allow your callback to be invoked async. Reacting to property changes asynchronously gives more room for the JS event loop to continue with other async work including user interactions, creating a better user experience.\\n\\n#### `whenOnce`\\n\\nThis is a convenience function to make it easier to `await` for a property to become truthy if you only need to wait for one change. You can pass an `AbortSignal` to the options to cancel waiting, in which case the returned promise will be aborted.\\n\\n```ts\\nawait whenOnce(obj, \\"myProp\\", { signal });\\n```\\n\\n#### `createIHandle`\\n\\nCreating a number of watches in one place is fairly common, which results in having a number of returned handles to deal with. To help simplify some situations we\u2019ve added this utility function `createIHandle` that takes an `Iterable<IHandle>` and returns a single `IHandle`. This is useful when combined with `onWatch` but also other scenarios.\\n\\n```ts\\nonWatch(this, \\"myProp\\", () => {\\n  const handles: IHandle[] = [];\\n  handles.push(\\n    watch(otherObj, \\"otherProp\\", () => notifyChange(this, \\"myProp\\"));\\n    watch(anotherObj, \\"anotherProp\\", () => notifyChange(this, \\"myProp\\"));\\n  );\\n  return createIHandle(handles);\\n});\\n```\\n\\nThe returned handle from `createIHandle` holds a reference to the iterable and will remove the handles currently held in the iterable when called, allowing you to update the iterable with new handles or remove old ones but still use the same returned handle to remove whatever is left in the iterable.\\n\\n### What did we Deprecate?\\n\\nAll classes that were inheriting from `Observable` (@vertigis/arcgis-extensions/support/Observable.ts) no longer inherit from `Observable`. Most have been updated to use the new mixin, however `SerializableBase` has not been updated to use the mixin as it did not make sense for this class to be observable on its own. Every class, including `SerializableBase`, that no longer inherits from `Observable` has had deprecated methods added to temporarily provide the previous methods from `Observable`. Support for `reactiveUtils` for all classes that were previously inheriting from `Observable` will still work as well during the transition period.\\n\\nIf you\u2019re unsure if you have any references to anything that will be removed, you can check the browser console; all deprecated functions, classes, and modules that are still in use are logged there as warnings.\\n\\n<table>\\n    <tr>\\n        <th>Deprecation</th>\\n        <th>Replacement</th>\\n    </tr>\\n    <tr>\\n        <td>\\n            `Observable`\\n            (@vertigis/arcgis-extensions/support/Observable.ts)\\n        </td>\\n        <td>\\n            `observable`\\n            (@vertigis/arcgis-extensions/support/observableUtils.ts)\\n        </td>\\n    </tr>\\n    <tr>\\n        <td>\\n            `Observable.watch`\\n            (@vertigis/arcgis-extensions/support/Observable.ts)\\n        </td>\\n        <td>\\n            `watch`\\n            (@vertigis/arcgis-extensions/support/observableUtils.ts)\\n        </td>\\n    </tr>\\n    <tr>\\n        <td>\\n            `Observable_watchProperty`\\n            (@vertigis/arcgis-extensions/support/Observable.ts)\\n        </td>\\n        <td>\\n            `watch`\\n            (@vertigis/arcgis-extensions/support/observableUtils.ts)\\n        </td>\\n    </tr>\\n    <tr>\\n        <td>\\n            `Observable.notifyChange`\\n            (@vertigis/arcgis-extensions/support/Observable.ts)\\n        </td>\\n        <td>\\n            `notifyChange`\\n            (@vertigis/arcgis-extensions/support/observableUtils.ts)\\n        </td>\\n    </tr>\\n    <tr>\\n        <td>\\n            `Observable.get`\\n            (@vertigis/arcgis-extensions/support/Observable.ts)\\n        </td>\\n        <td>No replacement. Access the property directly instead.</td>\\n    </tr>\\n    <tr>\\n        <td>\\n            `Observable.set`\\n            (@vertigis/arcgis-extensions/support/Observable.ts)\\n        </td>\\n        <td>No replacement. Access the property directly instead.</td>\\n    </tr>\\n    <tr>\\n        <td>\\n            `watchEach`\\n            (@vertigis/arcgis-extensions/utilities/watch.ts)\\n        </td>\\n        <td>\\n            `watchEach`\\n            (@vertigis/arcgis-extensions/support/observableUtils.ts)\\n        </td>\\n    </tr>\\n    <tr>\\n        <td>\\n            `watchCollectionPropertyEach`\\n            (@vertigis/arcgis-extensions/utilities/watch.ts)\\n        </td>\\n        <td>\\n            `watchEach`\\n            (@vertigis/arcgis-extensions/support/observableUtils.ts)\\n        </td>\\n    </tr>\\n    <tr>\\n        <td>\\n            `ObservableWeakSet`\\n            (@vertigis/arcgis-extensions/utilities/ObservableWeakSet.ts)\\n        </td>\\n        <td>\\n            No replacement. This class did not make sense. You can\'t\\n            observe a weak set for changes.\\n        </td>\\n    </tr>\\n</table>\\n\\n#### `reactiveUtils` Support\\n\\nAt the time of writing this, `reactiveUtils` will still work with VertiGIS Studio Web (Web) classes. We\u2019ve ensured backwards compatibility for the moment.\\nHowever, moving forward, we do plan to remove support for `reactiveUtils` from Web entirely, so using `reactiveUtils` inside of Web or the Web SDK is now considered deprecated. Instead, Web SDK developers should use `observableUtils` only, even with ArcGIS JS SDK classes. This will insulate everyone from changes to the ArcGIS JS SDK watch system in the future and will eventually allow us to clean up a lot of memory leaks. It should also improve performance of Web and Web SDK apps once backwards compatibility is removed.\\n\\n#### Certain `useWatch` and `useWatch` Variant Overloads\\n\\nAs a consequence of the new watch pattern and the deprecation of using `reactiveUtils` inside Web, the `useWatch` overloads that use the watch value callback pattern similar to `reactiveUtils` `watch` have been deprecated. We\u2019ve also deprecated passing an array of property paths to `useWatch` and some specific `useWatch` variants, however we have maintained the array pattern for `useWatchAndRerender`.\\n\\nWe\u2019ve also deprecated the `useWatch` callback that has the `propertyName` and `target`. In future, `useWatch` will only pass the `newValue` and `oldValue` arguments to the callback.\\n\\n```ts\\n/** Deprecated */\\nuseWatch(() => myObj.myProp, callback);\\n/** Use instead */\\nuseWatch(myObj, \\"myProp\\", callback);\\n\\n/** Deprecated */\\nuseWatch(myObj, [\\"myProp1\\", \\"myProp2\\"], callback);\\n/** Use instead */\\nuseWatch(myObj, \\"myProp1\\", callback);\\nuseWatch(myObj, \\"myProp2\\", callback);\\n\\n/** Deprecated */\\nuseWatchAndRerender(() => myObj.myProp);\\n/** Use instead */\\nuseWatchAndRerender(myObj, \\"myProp\\");\\n\\n/** Deprecated */\\nuseWatchInit(() => myObj.myProp, callback);\\n/** Use instead */\\nuseWatchInit(myObj, \\"myProp\\", callback);\\n\\n/** Deprecated */\\nuseWatchInit(myObj, [\\"myProp1\\", \\"myProp2\\"], callback);\\n/** Use instead */\\nuseWatchInit(myObj, \\"myProp1\\", callback);\\nuseWatchInit(myObj, \\"myProp2\\", callback);\\n\\n/** Deprecated */\\nuseWatchEach(() => myObj.myProp, callback);\\n/** Use instead */\\nuseWatchEach(myObj, \\"myProp\\", callback);\\n\\n/** Deprecated */\\nuseWatchEach(myObj, [\\"myProp1\\", \\"myProp2\\"], callback);\\n/** Use instead */\\nuseWatchEach(myObj, \\"myProp1\\", callback);\\nuseWatchEach(myObj, \\"myProp2\\", callback);\\n\\n/** Deprecated */\\nuseWatchEachAndRerender(() => myObj.myProp);\\n/** Use instead */\\nuseWatchEachAndRerender(myObj, \\"myProp\\");\\n```\\n\\n### Common Anti-Patterns to Avoid\\n\\nWe\u2019ve seen various different anti-patterns over the years with the previous watch system that will likely continue with the new one. We\u2019re calling them out here to try to make people aware of these anti-patterns and their consequences of being used.\\n\\nAlso, with the addition of new watch functionality, there are also some new anti-patterns we expect to see come up from time to time that should also be avoided.\\n\\n#### Watching a Property on `this`\\n\\nPlease pay close attention to watches that use `this` as the watch object. This is an anti-pattern and should be avoided.\\n\\n```ts\\nwatch(this as MyClass, \\"myProp\\", callback);\\n```\\n\\nWhile it is simple to create a watch and sometimes more complicated to get the right behavior with other options, it is still less performant to use the watch system for watching a property on `this` than other options, like using an accessor property instead and calling your callback equivalent in the setter, even with our new watch system.\\n\\n#### `watch` Callback Invokes `notifyChange`\\n\\nUsing a watch with `notifyChange` for a property on the current object when not wrapped in `onWatch` is now an anti-pattern.\\n\\n```ts\\n// This is an anti-pattern.  Wrap this in onWatch instead.\\nwatch(this.obj, \\"objProp\\", () => notifyChange(this, \\"myProp\\"));\\n```\\n\\nThe above is always watching and notifying about those properties, even if no one cares. While this is a common pattern, and needed in most cases where it is used, we\u2019ve introduced a new function called `onWatch` to assist with this situation and make it more performant by only initiating the watch once it is actually needed making this pattern a new anti-pattern. See [`onWatch`](2025-08-05-web-observable-overhaul.mdx#onwatch) for an example of the new pattern to use.\\n\\n#### Calling `notifyChange` in a Setter for the Property Being Set\\n\\nThere is no need to call `notifyChange` inside a setter for the property the setter is for. Doing so creates a bit of extra work that is not necessary.\\n\\n```ts\\nclass MyClass extends observable() {\\n    get myProp() {\\n        return this._backingProp;\\n    }\\n    set myProp(value: number) {\\n        this._backingProp = value;\\n        // There is no need to call this notifyChange for this property.\\n        // The watch system is able to detect this change on its own.\\n        notifyChange(this, \\"myProp\\");\\n\\n        // We do need to call notifyChange for myOtherProp though.\\n        notifyChange(this, \\"myOtherProp\\");\\n    }\\n\\n    get myOtherProp() {\\n        return this._backingProp + 1;\\n    }\\n}\\n```\\n\\n#### Using `onCollectionPropertyChange` But Ignoring the Passed Event Object\\n\\nIf you\'re using `onCollectionPropertyChange` (@vertigis/arcgis-extensions/utilities/watch.ts) to detect changes but the actual change event value was being ignored, please use `watchEvent` (@vertigis/arcgis-extensions/support/observableUtils.ts) instead as it will have better performance when the underlying watched property changes.\\n\\n```ts\\nfunction collectionPropertyChange() {\\n    console.log(\\n        \\"do something that doesn\u2019t require the change event value\\"\\n    );\\n}\\n\\n/** Do not do this **/\\nonCollectionPropertyChange(\\n    myObj,\\n    \\"myCollectionProp\\",\\n    collectionPropertyChange\\n);\\n\\n/** Instead, do this **/\\nwatchEvent(\\n    myObj,\\n    \\"myCollectionProp\\",\\n    [\\"change\\", collectionPropertyChange],\\n    collectionPropertyChange\\n);\\n```\\n\\n`watchEvent` has two callbacks, one for the event and one for when the property being watched changes. By using the same callback for both, the callback will be invoked when the property value itself changes as well as the when the event is fired, creating the equivalent behavior of `onCollectionPropertyChange`, but without the difference being calculated between the two different `Collection`s when the property value changes."},{"id":"/2025/06/04/mobile-sdk-ai-image-recognition","metadata":{"permalink":"/blog/2025/06/04/mobile-sdk-ai-image-recognition","source":"@site/blog/2025-06-04-mobile-sdk-ai-image-recognition.mdx","title":"Using AI Image Recognition with the VertiGIS Studio Mobile SDK","description":"AI has been a hot topic lately. Naturally, the question has come up of how we can use AI with Studio products. With the Mobile SDK, it\'s already possible to integrate AI into a custom app. In this blog post I\'ll describe an example of just that, where we\'ll use AI image recognition to help create features.","date":"2025-06-04T00:00:00.000Z","tags":[{"inline":true,"label":"mobile","permalink":"/blog/tags/mobile"},{"inline":true,"label":"sdk","permalink":"/blog/tags/sdk"},{"inline":true,"label":"samples","permalink":"/blog/tags/samples"},{"inline":true,"label":"ai","permalink":"/blog/tags/ai"}],"readingTime":7.61,"hasTruncateMarker":true,"authors":[{"name":"Felicity Rhone","title":"Software Developer","url":"https://github.com/Felicity-R","imageURL":"https://github.com/felicity-r.png","key":null,"page":null}],"frontMatter":{"title":"Using AI Image Recognition with the VertiGIS Studio Mobile SDK","author":"Felicity Rhone","authorTitle":"Software Developer","authorURL":"https://github.com/Felicity-R","authorImageURL":"https://github.com/felicity-r.png","tags":["mobile","sdk","samples","ai"]},"unlisted":false,"prevItem":{"title":"VertiGIS Studio Web 5.37 Observable Overhaul","permalink":"/blog/2025/08/05/web-observable-overhaul"},"nextItem":{"title":"Override Search Area in VertiGIS Studio Mobile","permalink":"/blog/2025/05/02/mobile-override-search-area"}},"content":"import Link from \\"@docusaurus/Link\\";\\nimport useBaseUrl from \\"@docusaurus/useBaseUrl\\";\\n\\nAI has been a hot topic lately. Naturally, the question has come up of how we can use AI with Studio products. With the Mobile SDK, it\'s already possible to integrate AI into a custom app. In this blog post I\'ll describe an example of just that, where we\'ll use AI image recognition to help create features.\\n\\n\x3c!--truncate--\x3e\\n\\n## Overview\\n\\nIn this sample, we use AI image recognition to populate attributes in a new feature. The high level flow looks like this:\\n\\n1. Capture an image from your device\\n2. Pass the image and a custom prompt into the AI service\\n3. Parse the AI response into feature attributes\\n4. Create a feature from these attributes, with the image as an attachment\\n5. Have the user review the generated feature and modify any fields if desired\\n\\nThere are several advantages to this kind of flow. For one thing, it allows you to fill in fields with data you may not know, like the scientific name of a particular tree, without having to look it up elsewhere. Another is that it speeds up the data entry process\u2014typing on a Mobile device in particular can be cumbersome, so starting with the fields filled out just ready for you to review is a nice benefit.\\n\\n## Implementing the custom project\\n\\nWe have [a Quickstart project](https://github.com/vertigis/vertigis-mobile-quickstart) already available on GitHub to help expedite the process of creating a custom Studio Mobile app. The code for this AI demo builds on the Quickstart as a base. You can find [the full project on GitHub](https://github.com/vertigis/vertigis-mobile-custom-extension-with-AI).\\n\\n### The AI Service\\n\\nOur sample here uses a model from [Azure OpenAI](https://learn.microsoft.com/en-us/azure/ai-services/openai/overview). Note that this model was not specifically trained to identify trees, though the results are still quite good. However, bear in mind that for your own real-life use cases you may want to use your own model rather than a generic one like this, in order to get better accuracy; particularly if your domain requires more niche expertise. That is outside the scope of this sample.\\n\\nThe AI service is set up in [OpenAIAssistant.cs](https://github.com/vertigis/vertigis-mobile-custom-extension-with-AI/blob/master/App1/OpenAIAssistant.cs).\\n\\n```cs showLineNumbers=7\\ninternal class OpenAIAssistant\\n{\\n\\t// highlight-next-line\\n    /** INSERT YOUR OWN DEPLOYMENT NAME / ENDPOINT / KEY HERE **/\\n    private const string deploymentName = \\"\\";\\n    private const string endpoint = \\"\\";\\n    private const string key = \\"\\";\\n\\n    private AzureOpenAIClient _openAIClient;\\n\\n    public OpenAIAssistant()\\n    {\\n        _openAIClient = new AzureOpenAIClient(new Uri(endpoint), new AzureKeyCredential(key));\\n    }\\n\\n    public async Task<ChatCompletion> QueryImageAsync(byte[] imageData, List<string> queries, string systemPrompt)\\n    {\\n        // Limit image to 2MB for quick response and less tokens used\\n        if (imageData.Length > 2097152)\\n        {\\n            throw new ArgumentException(\\"Image exceeded 2MB, try downsizing the image\\");\\n        }\\n\\n        if (imageData.Length == 0)\\n        {\\n            throw new ArgumentException(\\"Image is invalid\\");\\n        }\\n\\n        // highlight-start\\n        var chatClient = _openAIClient.GetChatClient(deploymentName);\\n        var chatContent = ChatMessageContentPart.CreateImagePart(imageBytes: BinaryData.FromBytes(imageData), \\"image/png\\");\\n        var systemChatMessage = new SystemChatMessage(systemPrompt);\\n        var imageChatMessage = new UserChatMessage(chatContent);\\n\\n        var chatMessages = new List<ChatMessage>\\n        {\\n            systemChatMessage,\\n            imageChatMessage,\\n        };\\n\\n        foreach (var query in queries)\\n        {\\n            var userChatMessage = new UserChatMessage(query);\\n            chatMessages.Add(userChatMessage);\\n        }\\n        // highlight-end\\n\\n        // highlight-next-line\\n        var chatCompletionOptions = new ChatCompletionOptions() { ResponseFormat = ChatResponseFormat.CreateJsonObjectFormat()};\\n        ChatCompletion chatCompletion = await chatClient.CompleteChatAsync(chatMessages, chatCompletionOptions);\\n        return chatCompletion;\\n    }\\n}\\n```\\n\\nNote that there are variables for a deployment name, endpoint URL and a key at the top of the file (lines 10-12). You will need to have your own values there in order to actually make the AI queries.\\nFrom line 34 to 49, we configure the chat client with a message and image which will be passed in by the caller - in QuickCaptureService.cs - described in the next section.\\nThe system prompt passed in on line 36 provides the model with context for any the queries we will be making.\\nThe ResponseFormat option being set to json on line 51 will make parsing the response easier.\\n\\nYou can learn more about how to interact with OpenAI models in the [Azure documentation](https://learn.microsoft.com/en-us/azure/ai-services/openai/).\\n\\n### The Mobile integration\\n\\nIntegrating the AI service with Mobile and creating the feature happens in [QuickCaptureService.cs](https://github.com/vertigis/vertigis-mobile-custom-extension-with-AI/blob/master/App1/QuickCaptureService.cs).\\n\\nFirst, we [create the service](https://developers.vertigisstudio.com/docs/mobile/sdk-services-create) and [set up a custom command](https://developers.vertigisstudio.com/docs/mobile/sdk-services-create#create-a-custom-command). This command can then be invoked from the I Want To... menu or from a button within the Mobile app, for example.\\n\\n```cs\\n// highlight-next-line\\n[assembly: Service(typeof(QuickCaptureService))]\\nnamespace App1\\n{\\n    // highlight-next-line\\n    public class QuickCaptureService : ServiceBase\\n    {\\n        private AllOperations _ops;\\n        private IDialogController _dialog;\\n        private MapRepository _mapRepo;\\n        private OpenAIAssistant _openAIAssistant;\\n\\n        public QuickCaptureService(CommonAppDependencies deps)\\n        {\\n            // Save some objects we\'ll want later\\n            _ops = deps.Operations;\\n            _dialog = deps.DialogController;\\n            _mapRepo = deps.MapRepo;\\n            _openAIAssistant = new OpenAIAssistant();\\n\\n            // Register our custom command. This is called by name later from the \\"I Want To...\\" menu.\\n            // highlight-next-line\\n            deps.OperationRegistry.VoidOperation(\\"custom.quick-capture\\").RegisterExecute(DoQuickCaptureAsync, this);\\n        }\\n\\n        private async Task DoQuickCaptureAsync()\\n        {\\n            ...\\n        }\\n    }\\n}\\n```\\n\\nThen we can fill in the contents of DoQuickCaptureAsync; the command implementation.\\n\\n```cs showLineNumbers=48\\nprivate async Task DoQuickCaptureAsync()\\n{\\n    // Get the map (the first/only available map), and the layer we want to add to\\n    var map = _mapRepo.AllMaps.EnumerateExisting().First().MapExtension;\\n    // highlight-next-line\\n    var layerExt = map.LayerExtensions.FindByLayerId(\\"1968288a255-layer-2\\"); // 1968288a255-layer-2 = the trees layer\\n    var table = layerExt.GetFeatureTable();\\n\\n    // Get current location (will place feature there)\\n    var position = await _ops.GeolocationOperations.GetPosition.ExecuteAsync();\\n    position = HandleZAndMValues(table, position);\\n\\n    // highlight-next-line\\n    EnhancedFileData fileData = await GetPhotoFromUser();\\n\\n    await _ops.UIOperations.DisplayBusyState.ExecuteAsync();\\n\\n    var systemPrompt = \\"You are a helpful assistant knowledgeable about trees\\";\\n\\n    var queries = new List<string>\\n    {\\n        \\"\\"\\"\\n        // highlight-start\\n        Fill out the following information about a specific tree, from the given image.\\n        {\\n            CommonName:\\n            ScientificName:\\n            Family:\\n            ConservationStatus:\\n            Health:\\n        }\\n        \'Health\' should be an evaluation of the health of the individual tree pictured.\\n        // highlight-end\\n        Respond only with JSON.\\n        \\"\\"\\",\\n    };\\n\\n    // highlight-next-line\\n    var response = await _openAIAssistant.QueryImageAsync(fileData.Data, queries, systemPrompt);\\n    Dictionary<string, object?> attributes = GetAttributesFromResponse(response.Content[0].Text);\\n\\n    // Create the new feature\\n    var vertiGISFeature = await GetNewFeature(layerExt, table, position, attributes);\\n\\n    // Add the photo as an attachment on the feature\\n    var attachmentArgs = new AddAttachmentArgs(fileData, [vertiGISFeature], map);\\n    // highlight-next-line\\n    await _ops.EditOperations.AddAttachment.ExecuteAsync(attachmentArgs);\\n\\n    await _ops.ResultsOperations.DisplayDetails.ExecuteAsync(vertiGISFeature);\\n\\n    // Launch the feature editing form so user can tweak values if necessary\\n    // highlight-next-line\\n    await _ops.EditOperations.DisplayUpdateFeature.ExecuteAsync(vertiGISFeature);\\n}\\n```\\n\\nLine 52 has the layer ID for our sample trees layer. You\'d want to replace it with your own layer. Although you could have a more complicated use case where the layer is populated dynamically, this process tends to work best with a specific known layer, so that you can tell the AI model exactly the attribute names you\'re looking for and what the values should look like. The prompt, starting on line 68, illustrates this: the keys listed there correspond exactly to the tree layer\'s attribute names. This makes it easy to convert the json response from the AI service directly into a feature without having to do any extra parsing.\\n\\nWe found that the AI Model did a fine job of inferring what kind of value we were looking for for most of the attributes just based on the name. However, for the \\"Health\\" attribute, the model was giving us responses that referred to the health of the species of tree in general, rather than doing a specific assessment for the individual specimen in the photo. For example, it would give us \\"this is a hardy species but is susceptible to root rot\\", rather than \\"this tree shows signs of a caterpillar infestation\\". Hence we included a note in the prompt clarifying the intention of that field (line 76). If you have a similar setup, where your attribute names may not be intuitive, or perhaps the values have to be constrained to a certain data type like enum values, you can elaborate on that here.\\n\\nTo get the image, we\'ll use the Mobile\'s [TakePhoto operation](https://developers.vertigisstudio.com/docs/mobile/api-commands-operations#operation-photos.take-photo). In this sample we also have the option of launching a file picker, to make testing easier.\\n\\n:::note\\nBe sure you allow your SDK apps to access the camera and/or file picker in your app, [as required for each platform](https://learn.microsoft.com/en-us/dotnet/maui/platform-integration/appmodel/permissions?view=net-maui-9.0&tabs=android#platform-differences).\\n:::\\n\\nStarting on line 81 is where we we call the AI service, get the attributes from the AI response, and create a feature. Note that we convert the feature into [a VertiGIS Feature](https://developers.vertigisstudio.com/docs/web/api-objects/#feature) type: this enables us to work with it more easily in other Mobile SDK functions, such as [adding the attachment](https://developers.vertigisstudio.com/docs/mobile/api-commands-operations#command-edit.add-attachment) (line 89) and [activating feature editing](https://developers.vertigisstudio.com/docs/mobile/api-commands-operations#command-edit.display-update-feature) (line 94).\\n\\nOur documentation page [Edit the Layout and App Config](https://developers.vertigisstudio.com/docs/mobile/sdk-edit-layout-app-config) explains the final piece of the puzzle, which is setting up your SDK app to point to your webmap, with the trees layer in this sample, and defining the layout (including adding a place to launch our custom AI command)."},{"id":"/2025/05/02/mobile-override-search-area","metadata":{"permalink":"/blog/2025/05/02/mobile-override-search-area","source":"@site/blog/2025-05-02-mobile-override-search-area.mdx","title":"Override Search Area in VertiGIS Studio Mobile","description":"VertiGIS Studio Mobile enables app developers to override the default search area, which is the current visible area of the map when the app is not backed by an MMPK, to a custom area (extent) of the developer\'s choosing. This requires hand-editing the app JSON and working out a few details. In this blog post, I will guide you on how to do that and how to define a custom extent for search to operate within.","date":"2025-05-02T00:00:00.000Z","tags":[{"inline":true,"label":"mobile","permalink":"/blog/tags/mobile"},{"inline":true,"label":"search","permalink":"/blog/tags/search"}],"readingTime":7.38,"hasTruncateMarker":true,"authors":[{"name":"Jack Basha","title":"Quality Assurance Analyst","url":"https://github.com/jackbasha","imageURL":"https://github.com/jackbasha.png","key":null,"page":null}],"frontMatter":{"title":"Override Search Area in VertiGIS Studio Mobile","author":"Jack Basha","authorTitle":"Quality Assurance Analyst","authorURL":"https://github.com/jackbasha","authorImageURL":"https://github.com/jackbasha.png","tags":["mobile","search"]},"unlisted":false,"prevItem":{"title":"Using AI Image Recognition with the VertiGIS Studio Mobile SDK","permalink":"/blog/2025/06/04/mobile-sdk-ai-image-recognition"},"nextItem":{"title":"Converting a VertiGIS Studio Mobile SDK project to .NET MAUI","permalink":"/blog/2025/02/13/mobile-sdk-maui-conversion"}},"content":"import Link from \\"@docusaurus/Link\\";\\nimport useBaseUrl from \\"@docusaurus/useBaseUrl\\";\\n\\nVertiGIS Studio Mobile enables app developers to override the default search area, which is the current visible area of the map when the app is not backed by an MMPK, to a custom area (extent) of the developer\'s choosing. This requires hand-editing the app JSON and working out a few details. In this blog post, I will guide you on how to do that and how to define a custom extent for search to operate within.\\n\\n\x3c!--truncate--\x3e\\n\\n## 1 - Creating the Search Override Workflow {#creating-search-override-workflow}\\n\\nTo start off the work, we\'ll need to head to VertiGIS Studio Workflow and create a new blank Workflow. Call it `Search Override`. This Workflow will be used to override the search functionality in Mobile.\\n\\nTo create the Workflow, you may either download and import this <a href={useBaseUrl(\\"workflows/mobile-search-override-skeleton.json\\")} download=\\"search-override-skeleton.json\\" target=\\"\\\\_blank\\">skeleton file</a> in Workflow Designer, or create and configure it yourself in the following way:\\n\\n1. Add a `Get Workflow Inputs` activity with ID `getWorkflowInputs1`\\n2. Add a `Set Property` activity, which we\'ll leave empty for now.\\n3. Add a `Run Command` activity; configure the parameters as follows:\\n    - `Command Name`: `=\\"tasks.search,results.display\\"`\\n    - `Command Parameter`: `=$getWorkflowInputs1.inputs.context`\\n\\nWe will be using this Workflow to override the default search behaviour in Mobile so that we change the search area prior to performing the search.\\n\\n## 2 - Finding the Area to Override Search\\n\\nThere are two ways of obtaining the extent numbers needed to override the search area: Using a layer\'s FullExtent property to obtain the extent, or using a geometry picker to create a custom search area.\\n\\nI will walk you through how to use both of these methods to enable the most amount of customization and to fit your use case.\\n\\n### 2.1 - Using a layer\'s FullExtent property to obtain the extent {#using-layer-bounds}\\n\\nUsing a layer to obtain the extent numbers is the more foolproof way since it doesn\'t involve hard-coding any specific numbers to Workflow.\\n\\n:::info Note\\n\\nThis is the _recommended_ way, as obtaining custom extent numbers is a more complicated process. However, while testing, I found this to cover a much larger area than what\'s actually covered by the features of the layer so, although this works to extend the search area, developers who want a finer control of the search area override should use the method described in [section 2.2](#using-custom-bounds).\\n\\n:::\\n\\nOn the `Search Override` Workflow, add a `Get Layer` activity to obtain a layer that will act as the basis of the search area. Add this activity **to the start** of the Workflow. Assuming the `Get Layer` activity\'s ID is `layer1`, we will be using `=$layer1.layer.Unwrap().FullExtent` as input to the `Set Property` activity; the [next section](#finishing-workflow) will point out how to fill the activity properly. `layer.unwrap()` is an undocumented function which unwraps a layer from what we use internally in VertiGIS Studio products into [ESRI\'s layer objects](https://developers.arcgis.com/net/api-reference/api/netwin/Esri.ArcGISRuntime/Esri.ArcGISRuntime.Mapping.FeatureLayer.html).\\n\\n### 2.2 - Using custom bounds to obtain the extent {#using-custom-bounds}\\n\\nCreating a custom search area requires a bit more work to obtain the required search extent numbers. To start off, you may either download and import this <a href={useBaseUrl(\\"workflows/mobile-geometry-via-geometry-picker.json\\")} download=\\"geometry-via-geometry-picker.json\\" target=\\"\\\\_blank\\">skeleton file</a> in Workflow Designer, or you can create it yourself.\\n\\nIf you wish to create the Workflow yourself: Create a new blank Workflow, call it something along the lines of `Get Geometry from Geometry Picker`. We will be using this Workflow to obtain the extent values from a geometry picker which will be used to define our search area. Follow these steps to configure the Workflow:\\n\\n1. Add a `Display Form` activity, with ID `form1`, and add a geometry picker in there. Make sure that the geometry type is set to `Polygon`\\n    <img\\n        src={useBaseUrl(\\"img/mobile-set-geometry-picker-type.png\\")}\\n    />\\n2. Add a `Convert To JSON` next and use `=$form1.state.geometryPicker1.value.geometry[0]` as the inputs to the `Object` parameter\\n3. Use another `Display Form` activity to display these results in a way that is easily copyable. Add a `Text Area` form element and a load event on the form\'s title that replaces the text area\'s value with the output from the `Convert To JSON` activity\\n    <img src={useBaseUrl(\\"img/mobile-set-text-area-with-json.png\\")} />\\n\\nThe output should look something like the following but unformatted; you may format it for readability. Ensure sure the first point matches the last point and that these two are the only identical points.\\n\\n```json\\n{\\n    \\"rings\\": [\\n        [\\n            [-13261447.128629405, 4248956.0934711397],\\n            [-13255720.535082744, 3797373.288077388],\\n            [-12575073.987822598, 3791646.6945307283],\\n            [-12581618.666161638, 4253046.5174330398],\\n            [-13261447.128629405, 4248956.0934711397]\\n        ]\\n    ],\\n    \\"spatialReference\\": { \\"wkid\\": 102100, \\"latestWkid\\": 3857 }\\n}\\n```\\n\\n:::danger Warning\\n\\nMake sure to copy the spatial reference info as the extent numbers are meaningless without them.\\n\\n:::\\n\\nAfter obtaining the JSON of the search area, add a `Get Geometry From JSON` activity to the `Search Override` Workflow, and use the JSON as input to the `Json` parameter for the `Get Geometry From JSON` activity you just added. Assuming the mentioned `Get Geometry From JSON` activity\'s ID is `geometry1`, we will be using `=$geometry1.geometry.Polygon` as input to the `Set Property` activity. The [next section](#finishing-workflow) will point out how to fill the activity properly.\\n\\n:::tip\\n\\nYou may include this `Get Geometry from Geometry Picker` Workflow in the main `Search Override` Workflow, instead of copying the values over, to allow a higher degree of customizability during run-time; however, that will require using the geometry picker to set create the bounds polygon every time a search is commenced.\\n\\nYou may either do so by using it as a separate sub-Workflow, or copy all the activities to the start of the `Search Override` Workflow. You will need to adjust the input of the `Get Geometry From JSON` activity accordingly.\\n\\n:::\\n\\n## 3 - Finishing the Workflow {#finishing-workflow}\\n\\nAfter finding the search area\'s geometry, the process is the same no matter which method of obtaining the search area you chose. After you\'ve performed the required setup as described in [section 2.1](#using-layer-bounds) or [section 2.2](#using-custom-bounds), head to the `Search Override` Workflow. There, we will populate the `Set Property` activity we\'ve added in [section 1](#creating-search-override-workflow). This activity is where we will replace the search area with the one we customized. Set up the activity as follows:\\n\\n-   `Object`: Use `=$getWorkflowInputs1.inputs.context`\\n-   `Property Name`: Use `=\\"SearchArea\\"`\\n-   `Property Value`:\\n    -   `=$layer1.layer.Unwrap().FullExtent` if you\'ve followed [section 2.1](#using-layer-bounds).\\n    -   `=$geometry1.geometry.Polygon` if you\'ve followed [section 2.2](#using-custom-bounds).\\n\\n:::tip\\n\\nYou may optionally add a graphical representation of the search area on the map. This might be helpful to visualize the search area and verify the work you\'ve done. You can do so by adding a `Get Symbol From JSON` activity and populate its `Json` input as follows:\\n\\n```json\\n={\\n  \\"type\\": \\"esriSFS\\",\\n  \\"style\\": \\"esriSFSSolid\\",\\n  \\"color\\": [34,237,24,150],\\n    \\"outline\\": {\\n    \\"type\\": \\"esriSLS\\",\\n    \\"style\\": \\"esriSLSSolid\\",\\n    \\"color\\": [110,110,110,150],\\n    \\"width\\": 1\\n  }\\n}\\n```\\n\\n_You may change the opacity value, the last number in the `color` parameter, to a lower value for better visualization._\\n\\nThen, add a `Create Feature` activity and fill out the inputs as follows:\\n\\n-   `Geometry`: Use the same value you used to fill `Property Value` input in the `Set Property` activity.\\n-   `Symbol`: Use the symbol created in the `Get Symbol From JSON` activity.\\n\\n:::\\n\\n## 4 - Updating the Mobile app JSON and overriding the Search functionality\\n\\nTo use this Workflow we\'ve created in Mobile, launch the SuDo editor in Designer using `Ctrl+Shift+E` and scroll to the bottom. There, add a new entry to reference the `Search Override` Workflow we created earlier. You may use the following template and replace `portalItem` with your Workflow\'s ArcGIS portal link:\\n\\n```json\\n{\\n    \\"id\\": \\"search-override-workflow\\",\\n    \\"title\\": \\"Search Override Workflow\\",\\n    \\"target\\": \\"auto\\",\\n    \\"portalItem\\": \\"<Replace me>\\",\\n    \\"commandArgumentInput\\": \\"context\\",\\n    \\"$type\\": \\"workflow\\"\\n}\\n```\\n\\nWhen done correctly, the app JSON should look like the following:\\n\\n<img\\n    src={useBaseUrl(\\"img/mobile-adding-workflow-via-sudo-editor.png\\")}\\n/>\\n\\nLastly, look up the search object in Designer, which you can find by searching (`Ctrl+F`) for `\\"$type\\": \\"search\\"`. Change it from\\n\\n```json\\n{\\n    \\"id\\": \\"search-config-1\\",\\n    \\"$type\\": \\"search\\"\\n},\\n```\\n\\nTo\\n\\n```json\\n{\\n    \\"id\\": \\"search-config-1\\",\\n    \\"onSearch\\": \\"workflow.run-XXXX-XXX-XX-XXXXX-XXXXXX\\",\\n    \\"$type\\": \\"search\\"\\n},\\n```\\n\\nWhere you replace the `XXX...` with the value of the `id` field you typed in the previous step. So it looks like the following:\\n\\n<img\\n    src={useBaseUrl(\\n        \\"img/mobile-overriding-search-using-workflow.png\\"\\n    )}\\n/>\\n\\nAfter that is done, click on the `Apply, I know what I\'m doing` button and wait for Designer to load, then save the app. Launch the app in Go and attempt to search for a feature that doesn\'t exist in the visible extent. If you\'ve done everything correctly, the search should go through with the configured extent."},{"id":"/2025/02/13/mobile-sdk-maui-conversion","metadata":{"permalink":"/blog/2025/02/13/mobile-sdk-maui-conversion","source":"@site/blog/2025-02-13-mobile-sdk-maui-conversion.mdx","title":"Converting a VertiGIS Studio Mobile SDK project to .NET MAUI","description":"As of our 5.30 release, VertiGIS Studio Mobile has been migrated from Xamarin Forms to .NET MAUI, on .NET 8. We\'ve now completed work to support MAUI in our nuget package as well, so the time has come for any Xamarin Forms projects using our SDK to do their own migration.","date":"2025-02-13T00:00:00.000Z","tags":[{"inline":true,"label":"mobile","permalink":"/blog/tags/mobile"},{"inline":true,"label":"maui","permalink":"/blog/tags/maui"},{"inline":true,"label":"sdk","permalink":"/blog/tags/sdk"},{"inline":true,"label":"samples","permalink":"/blog/tags/samples"}],"readingTime":6.53,"hasTruncateMarker":true,"authors":[{"name":"Felicity Rhone","title":"Software Developer","url":"https://github.com/Felicity-R","imageURL":"https://github.com/felicity-r.png","key":null,"page":null}],"frontMatter":{"title":"Converting a VertiGIS Studio Mobile SDK project to .NET MAUI","author":"Felicity Rhone","authorTitle":"Software Developer","authorURL":"https://github.com/Felicity-R","authorImageURL":"https://github.com/felicity-r.png","tags":["mobile","maui","sdk","samples"]},"unlisted":false,"prevItem":{"title":"Override Search Area in VertiGIS Studio Mobile","permalink":"/blog/2025/05/02/mobile-override-search-area"},"nextItem":{"title":"VertiGIS Mobile Now Supports ArcGIS Maps SDK 200.x","permalink":"/blog/2024/08/22/mobile-maui-announcement"}},"content":"import Link from \\"@docusaurus/Link\\";\\nimport useBaseUrl from \\"@docusaurus/useBaseUrl\\";\\n\\nAs of our 5.30 release, VertiGIS Studio Mobile has been migrated from Xamarin Forms to .NET MAUI, on .NET 8. We\'ve now completed work to support MAUI in our nuget package as well, so the time has come for any Xamarin Forms projects using our SDK to do their own migration.\\nIn this blog post I\'ll walk you through the process, using our [VertiGIS Mobile Samples](https://github.com/vertigis/vertigis-mobile-samples) project as an example.\\n\\n\x3c!--truncate--\x3e\\n\\nYou can find the PR for this conversion in our samples repo here: https://github.com/vertigis/studio-dev-center/pull/79\\n\\nThere are some helpful guides out there already. For example, Microsoft has written [_Upgrade a Xamarin.Forms app to a .NET MAUI app with the .NET Upgrade Assistant_](https://learn.microsoft.com/en-us/dotnet/maui/migration/upgrade-assistant?view=net-maui-9.0&tabs=vswin) and\\n[_Manually upgrade a Xamarin.Forms app to a single project .NET MAUI app_](https://learn.microsoft.com/en-us/dotnet/maui/migration/multi-project-to-single-project?view=net-maui-9.0), which I do recommend checking out.\\nHowever, I will detail some specific errors I encountered along the way, which may provide some extra help.\\n\\nThe method I\'ll be going through will result in one shared project, and separate projects for each platform - the structure you\'re probably familiar with from your Xamarin Forms app. It is possible afterwards to merge these projects together to take advantage of MAUI\'s convenient single-project structure. To do so, I recommend creating a brand new single-project MAUI app and moving your files over, the way Microsoft describes in their \\"_Manually upgrade \\\\[...]_\\" article I linked above.\\nThis blog post will not talk about the process of converting custom Renderers to use the new MAUI Handler pattern, but if you do have custom Renderers that is something you\'ll have to handle as well during your upgrade process.\\n\\n## Step 1 - Run the .NET Upgrade Assistant\\n\\nWe\'ll be using the [.NET Upgrade Assistant](https://learn.microsoft.com/en-us/dotnet/core/porting/upgrade-assistant-overview) to help us through the first step.\\nIt won\'t get you to 100%, but it\'s a good starting point. You can find installation instructions [here](https://learn.microsoft.com/en-us/dotnet/maui/migration/upgrade-assistant?view=net-maui-8.0&tabs=vswin#installation).\\n\\nOnce you\'ve installed it, run the tool on each project in your Xamarin Forms solution, to upgrade it to a newer .NET version - in this case, .NET 8 (which will also necessarily migrate your project from Xamarin Forms to MAUI).\\n\\n## Step 2 - Upgrade packages\\n\\nThe Upgrade Assistant will have done some package updates automatically, but not all of them.\\nIf you\'re referencing any Esri ArcGIS Runtime packages, you\'ll need to upgrade those from 100.x to the 200.x version (as of writing this post, Mobile is using 200.5).\\nIn some cases you\'ll need a different package rather than just changing the version number; for example, Esri.ArcGISRuntime.Xamarin.Forms is replaced by Esri.ArcGISRuntime.MAUI.\\n\\n:::note\\n\\nFor the VertiGIS.Mobile nuget package, you\'ll need to update to version 5.34.x.\\nNote: due to [a known MAUI issue (Issue #19840)](https://github.com/dotnet/maui/issues/19840),\\nyou\'ll need to add `ExcludeAssets=\\"buildTransitive;build\\" PrivateAssets=\\"all\\"` to your package reference for the Mobile package - only in your base shared project. It\'s not necessary to add in the platform-specific projects. So it\'ll look like this:\\n\\n```xml\\n<PackageReference Include=\\"VertiGIS.Mobile\\" Version=\\"5.34.0\\" ExcludeAssets=\\"buildTransitive;build\\" PrivateAssets=\\"all\\" />\\n```\\n\\nThis issue only affects multi-projects; if you\'re converting to a single-project, it won\'t be necessary.\\n\\n:::\\n\\n:::info Important\\nThere\'s also a new step you\'ll need to add to use our package: in the MAUIProgram.cs file for each of the platform projects, you\'ll need to add a call to `UseStudioMobile`. It should end up looking like this:\\n\\n```cs\\npublic static MAUIApp CreateMAUIApp()\\n{\\n    var builder = MAUIApp.CreateBuilder();\\n\\n    builder\\n    .UseSharedMAUIApp()\\n    // highlight-next-line\\n    .UseStudioMobile();\\n\\n    return builder.Build();\\n}\\n```\\n\\n:::\\n\\n## Step 3 - Remove any lingering outdated references\\n\\nDo a search through your codebase for any remaining references to Xamarin.Forms. There are probably some instances that the Upgrade Assistant didn\'t handle. For example:\\n\\n```cs\\n// TODO Xamarin.Forms.Device.RuntimePlatform is no longer supported. Use Microsoft.MAUI.Devices.DeviceInfo.Platform instead. For more details see https://learn.microsoft.com/en-us/dotnet/maui/migration/forms-projects#device-changes\\nif (Xamarin.Forms.Device.RuntimePlatform != Xamarin.Forms.Device.UWP)\\n{\\n    AppManager.Instance.OnActivated();\\n}\\n```\\n\\nwill become:\\n\\n```cs\\nif (DeviceInfo.Platform != DevicePlatform.WinUI)\\n{\\n    AppManager.Instance.OnActivated();\\n}\\n```\\n\\n(Note the change from UWP to WinUI).\\n\\nA few types in Mobile, like the `EnhancedActivityIndicator` and `EnhancedSwitch` which were previously used in our Samples, have been removed as no longer necessary. Instead you should use MAUI\'s standard controls, in this case `ActivityIndicator` or `Switch`.\\n\\n## Step 4 - Fix other build errors\\n\\nTo fix this problem in your solution:\\n\\n<img\\n    src={useBaseUrl(\\"img/mobile-sdk-configuration-mapping-error.png\\")}\\n/>\\nOpen your .sln file in a text editor and delete everything in the `GlobalSection(ProjectConfigurationPlatforms)\\n= postSolution` section. When you re-open the sln file in Visual Studio,\\nit will repopulate that section correctly.\\n\\nOn Windows, the build error `Type \'App\' already defines a member called \'InitializeComponent\' with the same parameter types` is solved by adding the following lines to the csproj:\\n\\n```xml\\n\x3c!-- We do not want WinUI XAML files to be processed as .NET MAUI XAML --\x3e\\n<EnableDefaultXamlItems>false</EnableDefaultXamlItems>\\n<EnableDefaultMAUIItems>false</EnableDefaultMAUIItems>\\n```\\n\\nIf you find that Visual Studio simply isn\'t giving you the option to deploy to Windows, you may be missing your launchsettings.json file. Ensure you add such a file under the Properties folder of your Windows project.\\n\\nThose are some specific errors I ran into while converting the Samples project. Continue working through your own project fixing any additional problems you might have, until you are able to build succesfully.\\n\\n## Step 5 - Migrate code from \\\\*.original files\\n\\nYou may have noticed that in Step 1 the Upgrade Assistant created copies of several platform-specific startup files, suffixed with .original.\\nE.g. `AppDelegate.cs.original`\\n\\nFor each of the platforms, compare the .original file to the new version and copy over any logic required. For example, your SDK project would likely have extended `VertiGISMobileActivity` and `VertiGISAppDelegate` for Android and iOS, respectively.\\nThe upgrade tool won\'t have preserved that, so you\'ll need to do that now.\\n\\n## Step 6 - Fix runtime errors\\n\\nAt this point you should be able to build and run your app, but will likely encounter some runtime errors.\\n\\nOn Android for example, you\'ll likely have to fix `[AndroidRuntime] java.lang.RuntimeException: Unable to get provider android.support.v4.content.FileProvider: java.lang.ClassNotFoundException: Didn\'t find class \\"android.support.v4.content.FileProvider\\" on path: [...]`\\nby making a change in your AndroidManifest.xml.\\n\\nChange\\n\\n```xml\\n<provider android:name=\\"android.support.v4.content.FileProvider\\" android:authorities=\\"${applicationId}.fileprovider\\" android:exported=\\"false\\" android:grantUriPermissions=\\"true\\">\\n```\\n\\nto\\n\\n```xml\\n<provider android:name=\\"androidx.core.content.FileProvider\\" android:authorities=\\"${applicationId}.fileprovider\\" android:exported=\\"false\\" android:grantUriPermissions=\\"true\\">\\n```\\n\\nAnd if your Android MainActivity had a custom name, make sure the name is still being set in MainActivity.cs.\\n\\nOn Windows, if you were merging in Mobile\'s VertiGISResources.xaml file in a merged dictionary, like `<ResourceDictionary Source=\\"VertiGIS.Mobile.UWP/Resources/VertiGISResources.xaml\\"/>`, you\'ll now need to update the path: `<ResourceDictionary Source=\\"VertiGIS.Mobile/Platforms/Windows/VertiGISResources.xaml\\"/>`.\\n`VertiGIS.Mobile.Toolkit.UWP/Resources/ToolkitResources.xaml` no longer exists as a separate file.\\n\\n## Step 7 - Update outdated controls\\n\\nOnce you\'ve got all the build and runtime errors sorted out, I strongly recommend updating certain MAUI controls to their new and improved counterparts.\\nThis article, [\\"Layout behavior changes from Xamarin.Forms\\"](https://learn.microsoft.com/en-us/dotnet/maui/migration/layouts?view=net-maui-9.0), has some useful information about this.\\n\\nIn particular, all `Frame` controls should be replaced with `Border`.\\n\\n`StackLayout` should be replaced by `VerticalStackLayout` or `HorizontalStackLayout`, or by `Grid`, depending on your use case.\\nFor the layout options, `*AndExpand` is no longer supported in MAUI, so any instances of `StartAndExpand` or `CenterAndExpand` for example should now be replaced by just `Start` or `Center`.\\nThe article I mentioned above explains [how to replace a `StackLayout`](https://learn.microsoft.com/en-us/dotnet/maui/migration/layouts?view=net-maui-9.0#stacklayout) to preserve the previous expanding behaviour."},{"id":"/2024/08/22/mobile-maui-announcement","metadata":{"permalink":"/blog/2024/08/22/mobile-maui-announcement","source":"@site/blog/2024-08-22-mobile-maui-announcement.mdx","title":"VertiGIS Mobile Now Supports ArcGIS Maps SDK 200.x","description":"A new version of VertiGIS Mobile, based on Esri\'s new 200.x ArcGIS Maps SDK for .NET, is now available as a beta.","date":"2024-08-22T00:00:00.000Z","tags":[{"inline":true,"label":"mobile","permalink":"/blog/tags/mobile"}],"readingTime":1.05,"hasTruncateMarker":true,"authors":[{"name":"Felicity Rhone","title":"Software Developer","url":"https://github.com/Felicity-R","imageURL":"https://github.com/felicity-r.png","key":null,"page":null}],"frontMatter":{"title":"VertiGIS Mobile Now Supports ArcGIS Maps SDK 200.x","author":"Felicity Rhone","authorTitle":"Software Developer","authorURL":"https://github.com/Felicity-R","authorImageURL":"https://github.com/felicity-r.png","tags":["mobile"]},"unlisted":false,"prevItem":{"title":"Converting a VertiGIS Studio Mobile SDK project to .NET MAUI","permalink":"/blog/2025/02/13/mobile-sdk-maui-conversion"},"nextItem":{"title":"Creating Custom Bands with the Inline SDK","permalink":"/blog/2023/06/20/inline-sdk"}},"content":"import Link from \\"@docusaurus/Link\\";\\n\\nA new version of VertiGIS Mobile, based on Esri\'s new 200.x ArcGIS Maps SDK for .NET, is now available as a beta.\\n\\n\x3c!--truncate--\x3e\\n\\nWith the new SDK, Esri dropped support for Xamarin Forms in favor of .NET MAUI. Therefore, upgrading to the 200.x SDK also necessitated updating our version of .NET and migrating VertiGIS Mobile from a Xamarin Forms-based solution to a MAUI-based solution.\\n\\nFor a large project like Mobile, which includes dozens of custom controls for each of our supported platforms (iOS, Android and Windows), this turned out to be a complicated and time-consuming endeavor. We had to contend not only with deprecations and breaking changes in the Esri SDK, MAUI, and other third-party libraries, but also with unexpected issues in MAUI, as it was in its early days itself when we started our upgrade and went through a few growing pains.\\n\\nWe are glad to finally be able to present the result of our hard work to the public. See [our Community post here](https://support.vertigis.com/hc/en-us/community/posts/20063879496594-Open-Beta-for-NET-200-x-MAUI-release-of-VertiGIS-Studio-Go) for more information on how to access the beta and to provide feedback."},{"id":"/2023/06/20/inline-sdk","metadata":{"permalink":"/blog/2023/06/20/inline-sdk","source":"@site/blog/2023-06-20-inline-sdk.mdx","title":"Creating Custom Bands with the Inline SDK","description":"With VertiGIS Inline 2.3 and later, users now have the ability to create their own custom bands that run right in Inline using the VertiGIS Inline SDK. These custom bands are made with React and TypeScript, giving authors total control over what the band can do. Today, we will run through the steps to build, deploy and use a custom band in an Inline view.","date":"2023-06-20T00:00:00.000Z","tags":[{"inline":true,"label":"inline","permalink":"/blog/tags/inline"},{"inline":true,"label":"web","permalink":"/blog/tags/web"}],"readingTime":19.11,"hasTruncateMarker":true,"authors":[{"name":"Michael Kowal","title":"Software Developer","url":"https://github.com/MichaelKowal","imageURL":"https://github.com/MichaelKowal.png","key":null,"page":null}],"frontMatter":{"title":"Creating Custom Bands with the Inline SDK","author":"Michael Kowal","authorTitle":"Software Developer","authorURL":"https://github.com/MichaelKowal","authorImageURL":"https://github.com/MichaelKowal.png","tags":["inline","web"]},"unlisted":false,"prevItem":{"title":"VertiGIS Mobile Now Supports ArcGIS Maps SDK 200.x","permalink":"/blog/2024/08/22/mobile-maui-announcement"},"nextItem":{"title":"Mobile Generic Event Listener","permalink":"/blog/2023/03/01/mobile-generic-event-listener"}},"content":"import Link from \\"@docusaurus/Link\\";\\nimport useBaseUrl from \\"@docusaurus/useBaseUrl\\";\\n\\nWith VertiGIS Inline `2.3` and later, users now have the ability to create their own custom bands that run right in Inline using the VertiGIS Inline SDK. These custom bands are made with React and TypeScript, giving authors total control over what the band can do. Today, we will run through the steps to build, deploy and use a custom band in an Inline view.\\n\\n\x3c!--truncate--\x3e\\n\\n:::note\\nTo use these new features, you will need the latest versions of VertiGIS Inline, VertiGIS Studio Web, and the VertiGIS Inline SDK.\\n:::\\n\\n## Getting Started\\n\\nYou will need a few tools to build a custom band:\\n\\n-   [Download and install Node.js](https://nodejs.org/en)\\n-   [Download and install Visual Studio Code](https://code.visualstudio.com/download)\\n\\nOnce you are set up with those you can create a folder with everything you need to build a custom band. With the terminal of your choice, create instance of inline sdk with\\n\\n```\\nnpx @vertigis/inline-sdk create <my-project>\\n```\\n\\nOpen the folder with the name you supplied in VS Code. You should see a number of files already there.\\n\\n## Exploring the SDK\\n\\nThere are a few key parts of the SDK that you can use to build your own custom band.\\n\\n### Registry Service\\n\\nCustom bands are registered in Inline using a custom VertiGIS Web service. This service is found in `src/services/CustomBandRegistry/CustomBandRegistry.ts`. This file loads any available custom bands and registers them with Inline when it is added to an app. It can register any number of custom bands at the same time.\\n\\n:::danger Warning\\nModifying this service is not recommended. It can result in unexpected behavior including causing your app to crash. Do so at your own risk.\\n:::\\n\\n### Types\\n\\nIn the `src/definitions/inline.d.ts` file you can find all of the Inline types that you can use to create your custom band. There are comments provided in this file to describe the uses of these types.\\n\\n### Sample Band\\n\\nThe Inline SDK comes preinstalled with a sample band that you can use for reference. In your SDK navigate to `src/bands/SampleBand`. In here you will find 4 files.\\n\\n-   `Band.css` contains the styles that are applied to the chart.\\n-   `Band.tsx` contains the React code that is run in Inline.\\n-   `designer.ts` describes the settings that are available when configuring a custom band in the Inline Designer.\\n-   `index.ts` combines it all together to be properly registered.\\n\\n## Creating a new band\\n\\nThe band we will be creating today will be able to display a video and seek to any point in the video based on the location of the crosshair on the map and on other inline charts.\\n\\nTo create a new band run\\n\\n```\\nnpx @vertigis/inline-sdk generate VideoBand\\n```\\n\\n:::info Important\\nThe `generate` command must be run from within the custom band project folder.\\n:::\\n\\n### Add settings for the Inline Designer\\n\\nThe `designer.ts` file provides the Inline designer with a settings schema to display configurable settings for a custom band. These settings can be any combination of:\\n\\n-   input\\n-   checkbox\\n-   radio\\n-   dropdown\\n\\nThe Sample Band has some examples of how to use these settings. The `src/bands/VideoBand/designer.ts` file will have a small function ready to go.\\n\\n```ts title=\\"src/bands/VideoBand/designer.ts\\"\\nimport { InlineDesignerConfig } from \\"inline\\";\\n\\nexport const getDesignerConfig = (): InlineDesignerConfig => {\\n    const config: InlineDesignerConfig = [\\n        {\\n            title: \\"Video Band Settings\\",\\n            fields: [],\\n        },\\n    ];\\n\\n    return config;\\n};\\n```\\n\\nThe `InlineDesignerConfig` is a list of settings sections. Each section has a name and list of fields that can be configured by users in the Inline designer.\\n\\nNext, add an input field for the video URL.\\n\\n```ts title=\\"src/bands/VideoBand/designer.ts\\"\\n// highlight-next-line\\nimport { InlineDesignerConfig, InputDesignerConfig } from \\"inline\\";\\n\\nexport const getDesignerConfig = () => {\\n    const config: InlineDesignerConfig = [\\n        {\\n            title: \\"Video Band Settings\\",\\n            fields: [],\\n        },\\n    ];\\n\\n    // highlight-start\\n    const urlField: InputDesignerConfig = {\\n        id: \\"url\\",\\n        type: \\"input\\",\\n        default: \\"\\",\\n        label: \\"Video URL\\",\\n        helpText:\\n            \\"The URL of the video. This must be a valid URL to a video file.\\",\\n    };\\n\\n    config[0].fields.push(urlField);\\n    // highlight-end\\n\\n    return config;\\n};\\n```\\n\\nThis pattern can be repeated to create any other settings that are necessary for the band.\\n\\n### Creating a Video Player React Hook\\n\\nWithout a video player, this band will not do much. Let\'s create one using a custom React Hook.\\n\\nCreate a new file the the `VideoBand` folder called `useVideoPlayer.ts`. In this file we will include all the tools we need to create an interactive video player in a custom band.\\n\\nSet up the hook as a function that takes a single parameter, `videoElement`. This is a reference to a video HTML element.\\n\\n```ts title=\\"src/bands/VideoBand/useVideoPlayer.ts\\"\\nconst useVideoPlayer = (\\n    videoElement: React.MutableRefObject<HTMLVideoElement>\\n) => {};\\n\\nexport default useVideoPlayer;\\n```\\n\\nAdd some state to track to current status of the player.\\n\\n```ts title=\\"src/bands/VideoBand/useVideoPlayer.ts\\"\\n// highlight-next-line\\nimport { useState } from \\"react\\";\\n\\nconst useVideoPlayer = (\\n    videoElement: React.MutableRefObject<HTMLVideoElement>\\n) => {\\n    // highlight-start\\n    const [playerState, setPlayerState] = useState({\\n        isPlaying: false,\\n        progress: 0,\\n        speed: 1,\\n        isMuted: false,\\n    });\\n    //highlight-end\\n};\\n```\\n\\nAdd a function to toggle the current play/pause state of the video.\\n\\n```ts title=\\"src/bands/VideoBand/useVideoPlayer.ts\\"\\nconst useVideoPlayer = (videoElement: React.MutableRefObject<HTMLVideoElement>) => {\\n    ...\\n    // highlight-start\\n    const togglePlay = () => {\\n        setPlayerState({\\n            ...playerState,\\n            isPlaying: !playerState.isPlaying\\n        });\\n    }\\n    //highlight-end\\n}\\n```\\n\\nAdd a function that updates the progress bar of the video as it is playing. The progress is any value between 0 and 100 and is not directly related to the length of the video.\\n\\n```ts title=\\"src/bands/VideoBand/useVideoPlayer.ts\\"\\nconst useVideoPlayer = (videoElement: React.MutableRefObject<HTMLVideoElement>) => {\\n    ...\\n    // highlight-start\\n    const handleOnTimeUpdate = () => {\\n        const progress = (videoElement.current.currentTime / videoElement.current.duration) * 100;\\n        setPlayerState({\\n            ...playerState,\\n            progress\\n        });\\n    };\\n    //highlight-end\\n}\\n```\\n\\nAdd a function to seek to any point in the video, taking a number that is the percentage of the video length that the video should start playing at.\\n\\n```ts title=\\"src/bands/VideoBand/useVideoPlayer.ts\\"\\nconst useVideoPlayer = (videoElement: React.MutableRefObject<HTMLVideoElement>) => {\\n    ...\\n    // highlight-start\\n    const seekTo = (value: number) => {\\n        if (value >= 0 && value <= 100) {\\n            videoElement.current.currentTime = (videoElement.current.duration / 100) * value;\\n            setPlayerState({\\n                ...playerState,\\n                progress: value\\n            });\\n        }\\n    };\\n    //highlight-end\\n}\\n```\\n\\nAdd functions to change the playback speed of the video and turn the sound on/off.\\n\\n```ts title=\\"src/bands/VideoBand/useVideoPlayer.ts\\"\\nconst useVideoPlayer = (videoElement: React.MutableRefObject<HTMLVideoElement>) => {\\n    ...\\n    // highlight-start\\n    const handleVideoSpeed = (event) => {\\n        const speed = +event.target.value;\\n        videoElement.current.playbackRate = speed;\\n        setPlayerState({\\n            ...playerState,\\n            speed\\n        });\\n    }\\n\\n    const toggleMute = () => {\\n        setPlayerState({\\n            ...isMuted: !playerState.isMuted\\n        });\\n    }\\n    //highlight-end\\n}\\n```\\n\\nAdd `useEffect` hooks that will update the muted state of the video player, the playback speed, and the current play/pause state of the video player when their respective states have been changed.\\n\\n```ts title=\\"src/bands/VideoBand/useVideoPlayer.ts\\"\\n// highlight-next-line\\nimport { useState, useEffect } from \\"react\\";\\n\\nconst useVideoPlayer = (videoElement: React.MutableRefObject<HTMLVideoElement>) => {\\n    ...\\n    // highlight-start\\n    useEffect(() => {\\n        videoElement.current.muted = playerState.isMuted;\\n    }, [playerState.isMuted, videoElement]);\\n\\n    useEffect(() => {\\n        videoElement.current.playbackRate = playerState.speed;\\n    }, [playerState.speed, videoElement]);\\n\\n    useEffect(() => {\\n        playerState.isPlaying ?\\n        void videoElement.current.play() :\\n        void videoElement.current.pause();\\n    }, [playerState.isPlaying, videoElement]);\\n    //highlight-end\\n}\\n```\\n\\nFinally, provide all of these functions to the consumer of the hook by returning an object containing everything needed to create an interactive video player.\\n\\n```ts title=\\"src/bands/VideoBand/useVideoPlayer.ts\\"\\n// highlight-next-line\\nimport { useState, useEffect } from \\"react\\";\\n\\nconst useVideoPlayer = (videoElement: React.MutableRefObject<HTMLVideoElement>) => {\\n    ...\\n    // highlight-start\\n    return {\\n        playerState,\\n        togglePlay,\\n        handleOnTimeUpdate,\\n        handleVideoSpeed,\\n        toggleMute,\\n        seekTo\\n    }\\n    //highlight-end\\n}\\n```\\n\\nWith everything put together, your `useVideoPlayer` hook should look like this:\\n\\n```ts title=\\"src/bands/VideoBand/useVideoPlayer.ts\\"\\nimport { useState, useEffect } from \\"react\\";\\n\\nconst useVideoPlayer = (\\n    videoElement: React.MutableRefObject<HTMLVideoElement>\\n) => {\\n    const [playerState, setPlayerState] = useState({\\n        isPlaying: false,\\n        progress: 0,\\n        speed: 1,\\n        isMuted: false,\\n    });\\n\\n    const togglePlay = () => {\\n        setPlayerState({\\n            ...playerState,\\n            isPlaying: !playerState.isPlaying,\\n        });\\n    };\\n\\n    const handleOnTimeUpdate = () => {\\n        const progress =\\n            (videoElement.current.currentTime /\\n                videoElement.current.duration) *\\n            100;\\n        setPlayerState({\\n            ...playerState,\\n            progress,\\n        });\\n    };\\n\\n    const seekTo = (value: number) => {\\n        if (value >= 0 && value <= 100) {\\n            videoElement.current.currentTime =\\n                (videoElement.current.duration / 100) * value;\\n            setPlayerState({\\n                ...playerState,\\n                progress: value,\\n            });\\n        }\\n    };\\n\\n    const handleVideoSpeed = (event) => {\\n        const speed = +event.target.value;\\n        videoElement.current.playbackRate = speed;\\n        setPlayerState({\\n            ...playerState,\\n            speed,\\n        });\\n    };\\n\\n    const toggleMute = () => {\\n        setPlayerState({\\n            ...playerState,\\n            isMuted: !playerState.isMuted,\\n        });\\n    };\\n\\n    useEffect(() => {\\n        videoElement.current.muted = playerState.isMuted;\\n    }, [playerState.isMuted, videoElement]);\\n\\n    useEffect(() => {\\n        videoElement.current.playbackRate = playerState.speed;\\n    }, [playerState.speed, videoElement]);\\n\\n    useEffect(() => {\\n        playerState.isPlaying\\n            ? void videoElement.current.play()\\n            : void videoElement.current.pause();\\n    }, [playerState.isPlaying, videoElement]);\\n\\n    return {\\n        playerState,\\n        togglePlay,\\n        handleOnTimeUpdate,\\n        handleVideoSpeed,\\n        toggleMute,\\n        seekTo,\\n    };\\n};\\n\\nexport default useVideoPlayer;\\n```\\n\\n### Creating the component\\n\\nNow, add the hook to your custom band. Open `src/bands/VideoBand/Band.tsx`. Here you will find a simple react component. This component is the entrypoint for the band. In the `Band` component, add a `player` ref and add your `useVideoPlayer` hook. Add the `props` function parameter to the component.\\n\\n```tsx title=\\"src/bands/VideoBand/Band.tsx\\"\\nimport React, { useRef } from \\"react\\";\\nimport { BandProps } from \\"inline\\";\\nimport \\"./Band.css\\";\\nimport useVideoPlayer from \\"./useVideoPlayer\\";\\n\\nexport const Band: React.FC<BandProps> = (props) => {\\n    const player = useRef<HTMLVideoElement>();\\n    const {\\n        playerState,\\n        togglePlay,\\n        handleOnTimeUpdate,\\n        handleVideoSpeed,\\n        toggleMute,\\n        seekTo,\\n    } = useVideoPlayer(player);\\n\\n    return <div className=\\"video-band\\">Video Band</div>;\\n};\\n```\\n\\nAdd a video player and controls in a wrapper in the return statement of the component. The video player will take the URL to your video, player ref and the `handleOnTimeUpdate` function as props to the video player. The URL will be accessed using the `band.customBandSettings` prop passed in to the custom band.\\n\\n:::note\\nThis custom video band only works with hosted videos, not embedded video players.\\n:::\\n\\n```tsx title=\\"src/bands/VideoBand/Band.tsx\\"\\nreturn (\\n    <div className=\\"video-band\\">\\n        // highlight-start\\n        <div className=\\"video-wrapper\\">\\n            <video\\n                ref={player}\\n                onTimeUpdate={handleOnTimeUpdate}\\n                src={props.band.customBandSettings.url ?? \\"\\"}\\n            />\\n            <div className=\\"controls\\"></div>\\n        </div>\\n        // highlight-end\\n    </div>\\n);\\n```\\n\\nThe first control we will add is the start/stop button. This will show an icon depending on whether the video is playing or paused. To use that icon we need to install an npm package, `react-icons`. Run\\n\\n```\\nnpm install react-icons\\n```\\n\\nin the terminal to install all the icons you will need for this project.\\n\\n```tsx title=\\"src/bands/VideoBand/Band.tsx\\"\\nimport { BiPlay, BiPause} from \\"react-icons/bi\\";\\n...\\nreturn (\\n    <div className=\\"video-band\\">\\n        <div className=\\"video-wrapper\\">\\n            ...\\n            <div className=\\"controls\\">\\n                // highlight-start\\n                <div className=\\"actions\\">\\n                    <button onClick={togglePlay}>\\n                        {!playerState.isPlaying ? (\\n                            <BiPlay color=\\"white\\" />\\n                        ) : (\\n                            <BiPause color=\\"white\\" />\\n                        )}\\n                    </button>\\n                </div>\\n                // highlight-end\\n            </div>\\n        </div>\\n    </div>\\n);\\n```\\n\\nAdd a progress bar that allows the user to seek through the length of the video and shows the current timestamp of the video. We also need to add a function to handle the input\'s onChange prop.\\n\\n```tsx title=\\"src/bands/VideoBand/Band.tsx\\"\\n// highlight-start\\nconst handleVideoProgress = (event: React.ChangeEvent<HTMLInputElement>) => {\\n    const value = isNaN(+event.target.value) ? 0 : +event.target.value;\\n    seekTo(value);\\n}\\n// highlight-end\\n\\nreturn (\\n    <div className=\\"video-band\\">\\n        <div className=\\"video-wrapper\\">\\n            ...\\n            <div className=\\"controls\\">\\n                {...}\\n                // highlight-start\\n                <input\\n                    type=\\"range\\"\\n                    min=\\"0\\"\\n                    max=\\"100\\"\\n                    value={playerState.progress}\\n                    onChange={handleVideoProgress}\\n                />\\n                // highlight-end\\n            </div>\\n        </div>\\n    </div>\\n);\\n```\\n\\nAdd a dropdown with some options for different playback speeds.\\n\\n```tsx title=\\"src/bands/VideoBand/Band.tsx\\"\\nreturn (\\n    <div className=\\"video-band\\">\\n        <div className=\\"video-wrapper\\">\\n            ...\\n            <div className=\\"controls\\">\\n                {...}\\n                // highlight-start\\n                <select\\n                    className=\\"velocity\\"\\n                    value={playerState.speed}\\n                    onChange={handleVideoSpeed}\\n                >\\n                    <option value=\\"0.50\\">0.50</option>\\n                    <option value=\\"1\\">1</option>\\n                    <option value=\\"1.25\\">1.25</option>\\n                    <option value=\\"2\\">2</option>\\n                </select>\\n                // highlight-end\\n            </div>\\n        </div>\\n    </div>\\n);\\n```\\n\\nThe last thing to add is the mute button.\\n\\n```tsx title=\\"src/bands/VideoBand/Band.tsx\\"\\nreturn (\\n    <div className=\\"video-band\\">\\n        <div className=\\"video-wrapper\\">\\n            ...\\n            <div className=\\"controls\\">\\n                {...}\\n                // highlight-start\\n                <button className=\\"mute-btn\\" onClick={toggleMute}>\\n                    {!playerState.isMuted ? (\\n                        <BiVolumeFull color=\\"white\\"/>\\n                    ) : (\\n                        <BiVolumeMute color=\\"white\\"/>\\n                    )}\\n                </button>\\n                // highlight-end\\n            </div>\\n        </div>\\n    </div>\\n);\\n```\\n\\nWith everything added your component should look like this:\\n\\n```tsx title=\\"src/bands/VideoBand/Band.tsx\\"\\nimport debounce from \\"lodash.debounce\\";\\nimport {\\n    BiPlay,\\n    BiPause,\\n    BiVolumeFull,\\n    BiVolumeMute,\\n} from \\"react-icons/bi\\";\\nimport React, { useEffect, useRef } from \\"react\\";\\nimport useVideoPlayer from \\"./useVideoPlayer\\";\\nimport \\"./Band.css\\";\\nimport { BandProps } from \\"inline\\";\\n\\nexport const Band: React.FC<BandProps> = (props) => {\\n    const player = useRef<HTMLVideoElement>();\\n    const {\\n        playerState,\\n        togglePlay,\\n        handleOnTimeUpdate,\\n        handleVideoSpeed,\\n        toggleMute,\\n        seekTo,\\n    } = useVideoPlayer(player);\\n\\n    const handleVideoProgress = (\\n        event: React.ChangeEvent<HTMLInputElement>\\n    ) => {\\n        const value = isNaN(+event.target.value)\\n            ? 0\\n            : +event.target.value;\\n        seekTo(value);\\n    };\\n\\n    return (\\n        <div className=\\"video-band container\\">\\n            <div className=\\"video-wrapper\\">\\n                <video\\n                    ref={player}\\n                    onTimeUpdate={handleOnTimeUpdate}\\n                    src={props.band.customBandSettings.url ?? \\"\\"}\\n                />\\n                <div className=\\"controls\\">\\n                    <div className=\\"actions\\">\\n                        <button onClick={togglePlay}>\\n                            {!playerState.isPlaying ? (\\n                                <BiPlay color=\\"white\\" />\\n                            ) : (\\n                                <BiPause color=\\"white\\" />\\n                            )}\\n                        </button>\\n                    </div>\\n                    <input\\n                        type=\\"range\\"\\n                        min=\\"0\\"\\n                        max=\\"100\\"\\n                        value={playerState.progress}\\n                        onChange={handleVideoProgress}\\n                    />\\n                    <select\\n                        className=\\"velocity\\"\\n                        value={playerState.speed}\\n                        onChange={handleVideoSpeed}\\n                    >\\n                        <option value=\\"0.50\\">0.50</option>\\n                        <option value=\\"1\\">1</option>\\n                        <option value=\\"1.25\\">1.25</option>\\n                        <option value=\\"2\\">2</option>\\n                    </select>\\n                    <button className=\\"mute-btn\\" onClick={toggleMute}>\\n                        {!playerState.isMuted ? (\\n                            <BiVolumeFull color=\\"white\\" />\\n                        ) : (\\n                            <BiVolumeMute color=\\"white\\" />\\n                        )}\\n                    </button>\\n                </div>\\n            </div>\\n        </div>\\n    );\\n};\\n```\\n\\n### Styling the band\\n\\nWith the band created let\'s add some styling. Add this to the `src/bands/VideoBand/Band.css` file:\\n\\n```css title=\\"src/bands/VideoBand/Band.css\\"\\n.video-band.container {\\n    display: flex;\\n    justify-content: center;\\n    align-items: center;\\n    padding: 2rem;\\n    width: 100%;\\n}\\n\\n.video-band h1 {\\n    color: white;\\n}\\n\\n.video-band video {\\n    width: 100%;\\n}\\n\\n.video-band .video-wrapper {\\n    width: 100%;\\n    max-width: 700px;\\n    position: relative;\\n    display: flex;\\n    justify-content: center;\\n    overflow: hidden;\\n    border-radius: 10px;\\n}\\n\\n.video-band .video-wrapper:hover .controls {\\n    transform: translateY(0%);\\n}\\n\\n.video-band .controls {\\n    display: flex;\\n    align-items: center;\\n    justify-content: space-evenly;\\n    position: absolute;\\n    bottom: 30px;\\n    padding: 14px;\\n    width: 100%;\\n    max-width: 500px;\\n    flex-wrap: wrap;\\n    background: rgba(255, 255, 255, 0.25);\\n    box-shadow: 0 8px 32px 0 rgba(255, 255, 255, 0.1);\\n    backdrop-filter: blur(4px);\\n    -webkit-backdrop-filter: blur(4px);\\n    border-radius: 10px;\\n    border: 1px solid rgba(255, 255, 255, 0.18);\\n    transform: translateY(150%);\\n    transition: all 0.3s ease-in-out;\\n}\\n\\n.video-band .actions button {\\n    background: none;\\n    border: none;\\n    outline: none;\\n    cursor: pointer;\\n}\\n\\n.video-band .actions button i {\\n    background-color: none;\\n    color: white;\\n    font-size: 30px;\\n}\\n\\ninput[type=\\"range\\"] {\\n    -webkit-appearance: none !important;\\n    background: rgba(255, 255, 255, 0.2);\\n    border-radius: 20px;\\n    height: 4px;\\n    width: 350px;\\n}\\n\\n.video-band input[type=\\"range\\"]::-webkit-slider-thumb {\\n    -webkit-appearance: none !important;\\n    cursor: pointer;\\n    height: 6px;\\n}\\n\\n.video-band input[type=\\"range\\"]::-moz-range-progress {\\n    background: white;\\n}\\n\\n.video-band .velocity {\\n    appearance: none;\\n    background: none;\\n    color: white;\\n    outline: none;\\n    border: none;\\n    text-align: center;\\n    font-size: 16px;\\n}\\n\\n.video-band .mute-btn {\\n    background: none;\\n    border: none;\\n    outline: none;\\n    cursor: pointer;\\n}\\n\\n.video-band .mute-btn i {\\n    background-color: none;\\n    color: white;\\n    font-size: 20px;\\n}\\n```\\n\\n## Deploying the band\\n\\n### Build the band\\n\\nNow that the band has been created, we can add it to VertiGIS Studio Web and load it into Inline. In the terminal, run\\n\\n```\\nnpm run start\\n```\\n\\nThis will start up a development server and create a temporary build of your custom band.\\n\\n### Adding the band to your app\\n\\nOpen VertiGIS Studio Web Designer. In Web Designer, open your Inline app.\\n\\n:::note\\nIf you do not have an existing Inline app you can create a new app using the VertiGIS Inline template.\\n:::\\n\\nIn your app, open the File menu. Open the Upload Library settings:\\n\\n<img src={useBaseUrl(\\"img/app-designer-upload-library.png\\")} />\\n\\nIn the popup, add `http://localhost:4444/main.js` as a library URL:\\n\\n<img src={useBaseUrl(\\"img/app-designer-upload-library-modal.png\\")} />\\n\\nClick the `Add Library` button beside the library link input. Click Save Changes. Your app will be saved and be refreshed.\\n\\nWith this done you can close Web Designer and open the Inline Designer.\\n\\n### Using a custom Web App in Inline\\n\\nIn the Inline designer, open the view you want to add the band to.\\n\\nOpen the Sandbox settings on the left side panel:\\n\\n<img src={useBaseUrl(\\"img/inline-sandbox-settings.png\\")} />\\n\\nAt the top of the panel, select `Change Web App`. This will open a window with a list of your VertiGIS Studio Web apps. Choose the Web app that you added your custom band library to.\\n\\nYou can confirm that the custom bands have been loaded by checking your browser console. You should see a console log for each band that has been loaded.\\n\\n<img src={useBaseUrl(\\"img/inline-custom-band-console.png\\")} />\\n\\n### Adding the custom band to your view\\n\\nWith Inline running your custom Web app, you can now add your band to your view using the Inline designer.\\n\\nAdd a new band to Inline. Open the new Band settings. In the `Band Type` dropdown choose \\"Custom\\".\\n\\n<img src={useBaseUrl(\\"img/inline-band-type-dropdown.png\\")} />\\n\\nIn the `Custom Band Name` dropdown, choose \\"VideoBand\\".\\n\\n<img src={useBaseUrl(\\"img/inline-band-name-dropdown.png\\")} />\\n\\nYou should see a new settings section with the option to add a Video URL. Add a URL to a `Video URL` setting.\\n\\n:::note\\nCustom bands will sometimes require a refresh of the Inline sandbox before you can see them reflected in the charts. Click the `Refresh Sandbox` button in the top left of the Inline designer if you are not seeing your custom band in your view.\\n:::\\n\\nChoose a route and range for your view. When the bands load you should see your custom video band playing with your video. Hovering over the video should show the video controls.\\n\\n<img src={useBaseUrl(\\"img/inline-video-band.png\\")} />\\n\\n## Syncing the band with Inline\\n\\nThe band that we have now will show and run a video with all the controls, but it won\'t sync with the rest of your Inline bands. In order to do that we need to listen to some inline events. The Inline SDK allows custom bands to listen for and fire any Inline events. Types and descriptions for these events can be found in the `definitions/Inline.d.ts` file in the project.\\n\\nOpen VS Code and the `src/bands/VideoBand/Band.tsx` file. Add a new `useEffect` hook to the Band component.\\n\\n```tsx title=\\"src/bands/VideoBand/Band.tsx\\"\\n// highlight-next-line\\nimport React, { useEffect, useRef } from \\"react\\";\\n...\\nexport const Band: React.FC<BandProps> = (props) => {\\n    ...\\n\\n    // highlight-next-line\\n    useEffect(() => {})\\n\\n    return(...)\\n}\\n```\\n\\nIn the `useEffect` hook we will add some Inline event handlers using the `InlineManager` that is passed to the component via the props.\\n\\n:::note\\nThe `InlineManager` has a variety of different tools that can be used from within a custom band that can change how you interact with Inline. Many of the tools are typed in the Inline SDK and can be found in the `definitions/Inline.d.ts` file.\\n:::\\n\\n```tsx title=\\"src/bands/VideoBand/Band.tsx\\"\\nuseEffect(() => {\\n    const mapCrosshairEvent = props.InlineManager.event(\\n        \\"ChartCrosshairLocationUpdateEvent\\"\\n    ).subscribe(undefined, handleCrosshairPositionChangeEvent);\\n    const chartCrosshairEvent = props.InlineManager.event(\\n        \\"XValueChangeEvent\\"\\n    ).subscribe(undefined, handleCrosshairPositionChangeEvent);\\n\\n    return () => {\\n        props.InlineManager.event(\\n            \\"ChartCrosshairLocationUpdateEvent\\"\\n        ).unsubscribe(mapCrosshairEvent);\\n        props.InlineManager.event(\\"XValueChangeEvent\\").unsubscribe(\\n            chartCrosshairEvent\\n        );\\n    };\\n});\\n```\\n\\nThere are two different events that we are listening for here. The `ChartCrosshairLocationUpdateEvent` is fired when the route is hovered over on the map. The `XValueChangeEvent` is fired when a chart is hovered over. Both of these will provide the same arguments and can be dealt with via the same handler.\\n\\nAdd a new function, `handleCrosshairPositionChangeEvent`, under the `useEffect` hook. This function will update the progress of the video to match the current location of the crosshair on the chart.\\n\\n```tsx title=\\"src/bands/VideoBand/Band.tsx\\"\\n// highlight-next-line\\nimport { BandProps, StationInfoEventArg } from \\"inline\\";\\n...\\nexport const Band: React.FC<BandProps> = (props) => {\\n    ...\\n\\n    // highlight-start\\n    const handleCrosshairPositionChangeEvent = (\\n        arg: StationInfoEventArg\\n    ) => {\\n        // Don\'t try to update the position if the video player does not exist.\\n        if (!player.current) {\\n            return;\\n        }\\n\\n        // Get the start and end measure of the current range to calculate the\\n        // percent along the line.\\n        const start =\\n            props.InlineManager.currentRange.beginStation.measure;\\n        const end = props.InlineManager.currentRange.endStation.measure;\\n\\n        // Ensure the measure is within the range.  If it is not, clamp it to prevent\\n        // any errors.\\n        const measure = Math.max(\\n            start,\\n            Math.min(end, arg.stationInfo.measure)\\n        );\\n\\n        const currentRangeLength = end - start;\\n        const percentageAlongLine =\\n            (measure - start) / currentRangeLength;\\n\\n        // Move the video progress to the corresponding percentage through the video\\n        // that matches the percentage along the line.\\n        seekTo(percentageAlongLine * 100);\\n\\n        // Pause the video to be able to see where the position that was jumped to is.\\n        if (playerState.isPlaying) {\\n            togglePlay();\\n        }\\n    };\\n    // highlight-end\\n\\n    return(...)\\n}\\n```\\n\\nThe last thing we want to do is add a debounce to the handler to prevent any performance issues that can happen when moving around a lot. Install Lodash\'s debounce tool with\\n\\n```\\nnpm install lodash.debounce\\n```\\n\\nWrap the `handleCrosshairPositionChangeEvent` in a debounce higher order function. Give the debounce a 100ms refresh argument. Create and add a type, `StationInfoEventHandler`, to the function.\\n\\n```tsx title=\\"src/bands/VideoBand/Band.tsx\\"\\n// highlight-next-line\\nimport debounce from \\"lodash.debounce\\";\\n...\\n// highlight-next-line\\ntype StationInfoEventHandler = (arg: StationInfoEventArg) => void;\\n\\nexport const Band: React.FC<BandProps> = (props) => {\\n    ...\\n\\n    // highlight-start\\n    const handleCrosshairPositionChangeEvent: StationInfoEventHandler = debounce((arg: StationInfoEventArg) => {\\n        ...\\n    }, [100])\\n    // highlight-end\\n\\n    return(...)\\n}\\n```\\n\\nWith the event handler and the event listeners added, the `Band.tsx` file should look like this:\\n\\n```tsx title=\\"src/bands/VideoBand/Band.tsx\\"\\nimport debounce from \\"lodash.debounce\\";\\nimport {\\n    BiPlay,\\n    BiPause,\\n    BiVolumeFull,\\n    BiVolumeMute,\\n} from \\"react-icons/bi\\";\\nimport React, { useEffect, useRef } from \\"react\\";\\nimport useVideoPlayer from \\"./useVideoPlayer\\";\\nimport \\"./Band.css\\";\\nimport { BandProps, StationInfoEventArg } from \\"inline\\";\\n\\nexport const Band: React.FC<BandProps> = (props) => {\\n    const player = useRef<HTMLVideoElement>();\\n    const {\\n        playerState,\\n        togglePlay,\\n        handleOnTimeUpdate,\\n        handleVideoSpeed,\\n        toggleMute,\\n        seekTo,\\n    } = useVideoPlayer(player);\\n\\n    /**\\n     * Subscribing to inline events can allow for better integration of custom bands into inline.\\n     */\\n    useEffect(() => {\\n        const mapCrosshairEvent = props.InlineManager.event(\\n            \\"ChartCrosshairLocationUpdateEvent\\"\\n        ).subscribe(undefined, handleCrosshairPositionChangeEvent);\\n        const chartCrosshairEvent = props.InlineManager.event(\\n            \\"XValueChangeEvent\\"\\n        ).subscribe(undefined, handleCrosshairPositionChangeEvent);\\n        return () => {\\n            props.InlineManager.event(\\n                \\"ChartCrosshairLocationUpdateEvent\\"\\n            ).unsubscribe(mapCrosshairEvent);\\n            props.InlineManager.event(\\n                \\"XValueChangeEvent\\"\\n            ).unsubscribe(chartCrosshairEvent);\\n        };\\n    });\\n\\n    /**\\n     * When the inline cursor moves, it should update the video progress to match.\\n     */\\n    const handleCrosshairPositionChangeEvent = debounce(\\n        (arg: StationInfoEventArg) => {\\n            // Don\'t try to update the position if the video player does not exist.\\n            if (!player.current) {\\n                return;\\n            }\\n\\n            // Get the start and end measure of the current range to calculate the\\n            // percent along the line.\\n            const start =\\n                props.InlineManager.currentRange.beginStation.measure;\\n            const end =\\n                props.InlineManager.currentRange.endStation.measure;\\n\\n            // Ensure the measure is within the range.  If it is not, clamp it to prevent\\n            // any errors.\\n            const measure = Math.max(\\n                start,\\n                Math.min(end, arg.stationInfo.measure)\\n            );\\n\\n            const currentRangeLength = end - start;\\n            const percentageAlongLine =\\n                (measure - start) / currentRangeLength;\\n\\n            // Move the video progress to the corresponding percentage through the video\\n            // that matches the percentage along the line.\\n            seekTo(percentageAlongLine * 100);\\n\\n            // Pause the video to be able to see where the position that was jumped to is.\\n            if (playerState.isPlaying) {\\n                togglePlay();\\n            }\\n        },\\n        [100]\\n    );\\n\\n    const handleVideoProgress = (\\n        event: React.ChangeEvent<HTMLInputElement>\\n    ) => {\\n        const value = isNaN(+event.target.value)\\n            ? 0\\n            : +event.target.value;\\n        seekTo(value);\\n    };\\n\\n    return (\\n        <div className=\\"video-band container\\">\\n            <div className=\\"video-wrapper\\">\\n                <video\\n                    src={props.band.customBandSettings.url ?? \\"\\"}\\n                    ref={player}\\n                    onTimeUpdate={handleOnTimeUpdate}\\n                />\\n                <div className=\\"controls\\">\\n                    <div className=\\"actions\\">\\n                        <button onClick={togglePlay}>\\n                            {!playerState.isPlaying ? (\\n                                <BiPlay color=\\"white\\" />\\n                            ) : (\\n                                <BiPause color=\\"white\\" />\\n                            )}\\n                        </button>\\n                    </div>\\n                    <input\\n                        type=\\"range\\"\\n                        min=\\"0\\"\\n                        max=\\"100\\"\\n                        value={playerState.progress}\\n                        onChange={handleVideoProgress}\\n                    />\\n                    <select\\n                        className=\\"velocity\\"\\n                        value={playerState.speed}\\n                        onChange={handleVideoSpeed}\\n                    >\\n                        <option value=\\"0.50\\">0.50</option>\\n                        <option value=\\"1\\">1</option>\\n                        <option value=\\"1.25\\">1.25</option>\\n                        <option value=\\"2\\">2</option>\\n                    </select>\\n                    <button className=\\"mute-btn\\" onClick={toggleMute}>\\n                        {!playerState.isMuted ? (\\n                            <BiVolumeFull color=\\"white\\" />\\n                        ) : (\\n                            <BiVolumeMute color=\\"white\\" />\\n                        )}\\n                    </button>\\n                </div>\\n            </div>\\n        </div>\\n    );\\n};\\n```\\n\\nSave the file. Open the Inline designer with the view configured with your custom band. Reload the page to get your new changes. You should be able to see the video scrub through as you hover over the charts and the map.\\n\\n## Production Build\\n\\nOnce you have a custom band working how you would like, you can create a optimized production build. In a terminal run\\n\\n```\\nnpm run build\\n```\\n\\nThis will create a `build` folder with a `main.js` file. We can replace the library link we previously added with the `main.js` file and your custom band will be accessible to anyone who uses your app.\\n\\nIn Web Designer, open the Upload Library panel. Remove the custom library URL. Save the changes.\\n\\n:::danger Warning\\nOnly remove the custom library URL, `http://localhost:4444/main.js`. Removing the Inline library can break your app and cause unexpected behavior.\\n:::\\n\\n:::danger Warning\\nSave your changes before uploading another library. Loading two libraries with the same service can cause unexpected behavior in Web Designer, including losing access to your app.\\n:::\\n\\nAfter saving the changes and reloading your app, Open the Update Library panel again. Instead of adding a URL, upload a file. Browse to your `<Inline SDK folder>/build/main.js`. Upload the file and save the changes.\\n\\nReturn to your Inline Designer. Reload the page. The custom band should work as expected.\\n\\n## Conclusion\\n\\nWith the information learned in this post you should be able to create your own custom Inline band. The sample band can be a great place to start and explore everything the Inline SDK can do. Using Inline events and the InlineManager can give you even more powerful tools to use in your custom bands, including running VertiGIS Studio Web Commands and Operations and even VertiGIS Studio Workflows!"},{"id":"/2023/03/01/mobile-generic-event-listener","metadata":{"permalink":"/blog/2023/03/01/mobile-generic-event-listener","source":"@site/blog/2023-03-01-mobile-generic-event-listener.mdx","title":"Mobile Generic Event Listener","description":"VertiGIS Studio Mobile 5.22 includes an exciting new capability for working with commands, operations, and events. This capability allows app authors to execute custom, configured actions in response to events raised in Mobile. To opt in to this behavior, app authors register an event listener (subscriber) for any given Mobile event. When this event is raised in Mobile, the corresponding configured command or operation is invoked.","date":"2023-03-01T00:00:00.000Z","tags":[{"inline":true,"label":"mobile","permalink":"/blog/tags/mobile"},{"inline":true,"label":"workflow","permalink":"/blog/tags/workflow"}],"readingTime":7.23,"hasTruncateMarker":true,"authors":[{"name":"Kenneth Walker","title":"Software Developer","url":"https://github.com/kewalker","imageURL":"https://github.com/kewalker.png","key":null,"page":null}],"frontMatter":{"title":"Mobile Generic Event Listener","author":"Kenneth Walker","authorTitle":"Software Developer","authorURL":"https://github.com/kewalker","authorImageURL":"https://github.com/kewalker.png","tags":["mobile","workflow"]},"unlisted":false,"prevItem":{"title":"Creating Custom Bands with the Inline SDK","permalink":"/blog/2023/06/20/inline-sdk"},"nextItem":{"title":"New Workflow Form Element API","permalink":"/blog/2021/03/22/new-workflow-element-api"}},"content":"import Link from \\"@docusaurus/Link\\";\\n\\nVertiGIS Studio Mobile `5.22` includes an exciting new capability for working with commands, operations, and events. This capability allows app authors to execute custom, configured actions in response to events raised in Mobile. To opt in to this behavior, app authors register an event listener (subscriber) for any given Mobile event. When this event is raised in Mobile, the corresponding configured command or operation is invoked.\\n\\n\x3c!--truncate--\x3e\\n\\n:::note\\nTo use these new features, you will need a `5.22+` version of VertiGIS Studio Mobile.\\n:::\\n\\nThe new events capability can be exercised in a few ways:\\n\\n-   [Registering an event listener and action](#register-a-listener)\\n-   [Command chaining](#command-chaining)\\n-   [Specifying a sender](#specify-a-sender)\\n-   [Workflow and context](#workflows-and-context)\\n-   [Raise custom event](#raise-custom-events)\\n\\n:::tip Want a complete list of events?\\nCheck out the [Events](https://developers.vertigisstudio.com/docs/mobile/api-events#events) for the complete list of eligible events that can be listened to.\\n:::\\n\\n## Register a Listener\\n\\nTo get started, you\'ll want to introduce a new item `$type` into your `app.json` configuration: the `event-listener`. Today, you\'ll need to manually configure this app item and any respective listeners. Support for configuring listeners through Designer will be coming soon.\\n\\n```json\\n{\\n    \\"$type\\": \\"event-listener\\",\\n    \\"id\\": \\"custom-event-listener\\",\\n    \\"listeners\\": [\\n        // ... to be populated with listeners ...\\n    ]\\n}\\n```\\n\\n### Wire up a new `Listener`\\n\\nWith the new `event-listener` app item, you register a listener to a given event and respond with a configured action. Below, we\'re taking advantage of the [map.viewpoint-changed](https://developers.vertigisstudio.com/docs/mobile/api-events/#event-map.viewpoint-changed) event. In particular, it\'s configured with the [highlights.clear](https://developers.vertigisstudio.com/docs/mobile/api-commands-operations#command-highlights.clear) command. When you pan the map, the `map.viewpoint-changed` event is raised, and in turn, our `highlights.clear` command is executed. No more highlights when we pan!\\n\\n```json\\n{\\n    \\"$type\\": \\"event-listener\\",\\n    \\"id\\": \\"custom-event-listener\\",\\n    \\"listeners\\": [\\n        {\\n            \\"event\\": \\"map.viewpoint-changed\\",\\n            \\"action\\": \\"highlights.clear\\"\\n        }\\n        // ... more listeners ...\\n    ]\\n}\\n```\\n\\nOf course, multiple listeners may be registered. They can listen to both distinct or duplicate events:\\n\\n```json\\n{\\n    \\"$type\\": \\"event-listener\\",\\n    \\"id\\": \\"custom-event-listener\\",\\n    \\"listeners\\": [\\n        {\\n            \\"event\\": \\"map.viewpoint-changed\\",\\n            \\"action\\": \\"highlights.clear\\"\\n        },\\n        {\\n            \\"event\\": \\"map.viewpoint-changed\\",\\n            \\"action\\": \\"highlights.clear-focus\\"\\n        },\\n        {\\n            \\"event\\": \\"layers.visibility-changed\\",\\n            \\"action\\": \\"log-viewer.display\\"\\n        }\\n        // ... more listeners ...\\n    ]\\n}\\n```\\n\\n:::danger Warning\\nThe event listener capability is only available after the map has begun initializing. Listeners for events that fire _before_ the `map.initializing` event will not trigger any actions.\\n:::\\n\\n## Command Chaining\\n\\nWe can pair event listening with [Command Chains](https://developers.vertigisstudio.com/docs/mobile/configuration-commands-operations/#command-chains) to react with multiple actions chained together. In the example below, we\'ll react to a map pan by both clearing highlights and closing the panel. Notice that we can mix the use of simple syntax with the dictionary syntax that can optionally provide arguments.\\n\\n```json\\n{\\n    \\"$type\\": \\"event-listener\\",\\n    \\"id\\": \\"custom-event-listener\\",\\n    \\"listeners\\": [\\n        {\\n            \\"event\\": \\"map.viewpoint-changed\\",\\n            \\"action\\": [\\n                \\"highlights.clear\\",\\n                {\\n                    \\"name\\": \\"panel.close-host-panel\\",\\n                    \\"arguments\\": {}\\n                }\\n            ]\\n        }\\n        // ... more listeners ...\\n    ]\\n}\\n```\\n\\n## Specify A Sender\\n\\nUse the `sender` property to configure the listener such that it **only** reacts to those events that originate from the specified sender. A sender could correspond to a given component or service. Specifying the sender is optional.\\n\\nTake the example below where two `map-extension`s are configured. Since `sender` is specified as \\"map-config-1\\", viewpoint changed events raised from this map will result in highlights being cleared. Viewpoint changed events raised from \\"map-config-2\\" are effectively ignored.\\n\\n```json\\n{\\n    \\"$type\\": \\"map-extension\\",\\n    \\"id\\": \\"map-config-1\\",\\n    \\"webMap\\": \\"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx1\\"\\n    // ...\\n},\\n{\\n    \\"$type\\": \\"map-extension\\",\\n    \\"id\\": \\"map-config-2\\",\\n    \\"webMap\\": \\"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx2\\"\\n    // ...\\n},\\n\\n// ...\\n\\n{\\n    \\"$type\\": \\"event-listener\\",\\n    \\"id\\": \\"custom-event-listener\\",\\n    \\"listeners\\": [\\n        {\\n            \\"event\\": \\"map.viewpoint-changed\\",\\n            \\"sender\\": \\"item://map-extension/map-config-1\\",\\n            \\"action\\": [\\"highlights.clear\\"]\\n        },\\n        // ... more listeners ...\\n    ]\\n}\\n```\\n\\n:::note\\nIf the `sender` is omitted, any instance of the raised event will trigger the configured action.\\n:::\\n\\n## Workflows and Context\\n\\nUsing this new capability, you can also configure a Studio Workflow as an action to invoke in response to an event being raised.\\n\\n:::tip Want to learn more about Studio Workflow?\\nCheck out the overview to learn more about [Studio Workflow](https://developers.vertigisstudio.com/docs/workflow/overview).\\n:::\\n\\nBelow, we\'ll configure a [workflow.run](https://developers.vertigisstudio.com/docs/mobile/api-commands-operations#command-workflow.run) action and listen to a [layers.visibility-changed](https://developers.vertigisstudio.com/docs/mobile/api-events#event-layers.visibility-changed) event. Notice that we can specify arguments for our action, which in this case, will be the `id` of a `$type: \\"workflow\\"` item in `app.json` configuration.\\n\\nIn this example, toggling an entry in the layer list will invoke the configured workflow.\\n\\n```json\\n{\\n    \\"$type\\": \\"event-listener\\",\\n    \\"id\\": \\"custom-event-listener\\",\\n    \\"listeners\\": [\\n        {\\n            \\"event\\": \\"layers.visibility-changed\\",\\n            \\"action\\": {\\n                \\"name\\": \\"workflow.run\\",\\n                \\"arguments\\": {\\n                    \\"id\\": \\"visibility-workflow\\" // this id corresponds to the id of the workflow item that we want to invoke\\n                }\\n            }\\n        },\\n        // ... more listeners ...\\n    ]\\n},\\n\\n// ...\\n\\n{\\n    // The corresponding Workflow that we want to invoke in response to an event.\\n    \\"$type\\": \\"workflow\\",\\n    \\"id\\": \\"visibility-workflow\\",\\n    \\"title\\": \\"My Visibility Workflow\\",\\n    \\"target\\": \\"auto\\",\\n    \\"portalItem\\": \\"https://www.arcgis.com/sharing/rest/content/items/xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\\",\\n    \\"commandArgumentInput\\": \\"context\\"\\n},\\n```\\n\\n### A Workflow with Context\\n\\nRunning a Workflow is a powerful way to react to events raised during an app session. Pairing a Workflow with the `context` capability gives us an opportunity to use an input from the event in the Workflow activity.\\n\\nNotice below that the Workflow item specifies a `commandArgumentInput` value of `context`:\\n\\n```json\\n{\\n    \\"$type\\": \\"workflow\\",\\n    \\"commandArgumentInput\\": \\"context\\"\\n    // ...\\n},\\n```\\n\\nUsing the `layers.visibility-changed` event, we configure a Workflow as an action, being mindful of the `commandArgumentInput`.\\n\\n```json\\n{\\n    \\"$type\\": \\"event-listener\\",\\n    \\"id\\": \\"custom-event-listener\\",\\n    \\"listeners\\": [\\n        {\\n            \\"event\\": \\"layers.visibility-changed\\",\\n            \\"action\\": {\\n                \\"name\\": \\"workflow.run\\",\\n                \\"arguments\\": {\\n                    \\"id\\": \\"visibility-workflow\\" // this id corresponds to the id of the workflow item that we want to invoke\\n                }\\n            }\\n        },\\n        // ... more listeners ...\\n    ]\\n},\\n\\n// ...\\n\\n{\\n    // The corresponding Workflow that we want to invoke in response to an event.\\n    \\"$type\\": \\"workflow\\",\\n    \\"id\\": \\"visibility-workflow\\",\\n    \\"title\\": \\"My Visibility Workflow\\",\\n    \\"target\\": \\"auto\\",\\n    \\"portalItem\\": \\"https://www.arcgis.com/sharing/rest/content/items/xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\\",\\n    \\"commandArgumentInput\\": \\"context\\"\\n},\\n```\\n\\nBy specifying the `context`, we\'re able to retrieve an input value within a Workflow using the [Get Workflow Inputs](https://docs.vertigisstudio.com/workflow/latest/help/get-workflow-inputs.html) activity.\\n\\nIn our Workflow, we would want to run `Get Workflow Inputs` as our first activity to retrieve the input. Once we have the input as an object in our Workflow, we can access the `context` to start working with the input.\\n\\nIn the case of the `layers.visibility-changed` event, we\'re able to retrieve and work with the `LayerContent` as an input to our Workflow. Below is an example of how to access the `LayerContent` from the `context` and get at the `id`, which could then be used in any subsequent activity, for example an alert or a query:\\n\\n```javascript\\n=$getWorkflowInputs1.inputs.context.LayerContent.id.toString()\\n```\\n\\n:::info Important\\nThe value provided to `commandArgumentInput` and the accessor used within the `Get Workflow Inputs` activity object **must** match to correctly access an input (i.e. both `context` in this example).\\n:::\\n\\n## Raise Custom Events\\n\\nWhile Mobile exposes a number of events that may be listened to, there are times where it would be beneficial to respond to events that _aren\'t_ raised out of the box. Fortunately, there are also capabilities that allow app authors to raise custom events.\\n\\n### Raise Event through Action\\n\\nUsing the new [viewer.publish-event](https://developers.vertigisstudio.com/docs/mobile/api-commands-operations#command-viewer.publish-event) command, a custom event can be raised. This action can be configured anywhere in the app that supports actions, like buttons, hooks, command chains, etc. Below is an example of a configured button action:\\n\\n```json\\n\\"action\\": {\\n    \\"name\\": \\"viewer.publish-event\\",\\n    \\"arguments\\": {\\n        \\"name\\": \\"custom.raised-event\\",\\n        \\"arguments\\": {}\\n    }\\n}\\n```\\n\\n### Raise Event through Workflow\\n\\nBut what if we want to raise a custom event during execution of a Workflow? Using the [Publish Event](https://docs.vertigisstudio.com/workflow/latest/help/publish-event.html) activity, it\'s possible to raise a custom event from anywhere in your Workflow logic. Simply provide the same custom event name to the `Event Name` input in the `Publish Event` activity. Arguments may also be provided. For the above example, that would be:\\n\\n```json\\ncustom.raised-event\\n```\\n\\n:::note\\nAlthough not recommended, it\'s also possible to use the `viewer.publish-event` command and the `Publish Event` activity to manually publish well-known Mobile events, i.e. `map.viewpoint-changed`.\\n:::\\n\\n### Subscribe to Custom Event\\n\\nOf course, publishing these events is only one side of the capabilities. Using the same mechanism introduced above, these custom raised events can be listened to, and configured with an action to invoke.\\n\\n```json\\n{\\n    \\"$type\\": \\"event-listener\\",\\n    \\"id\\": \\"custom-event-listener\\",\\n    \\"listeners\\": [\\n        {\\n            \\"event\\": \\"custom.raised-event\\",\\n            \\"action\\": \\"...\\"\\n        }\\n    ]\\n}\\n```\\n\\nCustom events could in turn raise more events with the `viewer.publish-event`, which could in turn be listened to. Together, the publishing and listening capabilities offer flexibility to respond to custom events with configured actions.\\n\\n## In Closing\\n\\nWe\'re excited to showcase these new capabilities for commands, operations, and events. We hope app authors can take advantage of them to create more responsive and exciting applications. Happy building!"},{"id":"/2021/03/22/new-workflow-element-api","metadata":{"permalink":"/blog/2021/03/22/new-workflow-element-api","source":"@site/blog/2021-03-22-new-workflow-element-api.mdx","title":"New Workflow Form Element API","description":"Workflow 5.21 includes a new TypeScript form element API that you can use for building custom form elements using the VertiGIS Studio Workflow TypeScript SDK. The existing patterns and APIs you\'ve been using for years to build custom form elements will continue to work, but we encourage you to try the new API when building new form elements.","date":"2021-03-22T00:00:00.000Z","tags":[{"inline":true,"label":"workflow","permalink":"/blog/tags/workflow"}],"readingTime":8.31,"hasTruncateMarker":true,"authors":[{"name":"Ian Schmitz","title":"Software Architect","url":"https://github.com/ianschmitz","imageURL":"https://github.com/ianschmitz.png","key":null,"page":null}],"frontMatter":{"title":"New Workflow Form Element API","author":"Ian Schmitz","authorTitle":"Software Architect","authorURL":"https://github.com/ianschmitz","authorImageURL":"https://github.com/ianschmitz.png","tags":["workflow"]},"unlisted":false,"prevItem":{"title":"Mobile Generic Event Listener","permalink":"/blog/2023/03/01/mobile-generic-event-listener"}},"content":"import Link from \\"@docusaurus/Link\\";\\n\\nWorkflow `5.21` includes a new TypeScript form element API that you can use for building custom form elements using the <Link to=\\"/docs/workflow/sdk-web-overview\\">VertiGIS Studio Workflow TypeScript SDK</Link>. The existing patterns and APIs you\'ve been using for years to build custom form elements will continue to work, but we encourage you to try the new API when building new form elements.\\n\\n\x3c!--truncate--\x3e\\n\\n:::note\\nTo use these new features, you will need the latest version of VertiGIS Studio Workflow, as well as the VertiGIS Studio Workflow SDK.\\n:::\\n\\nThe new form element API provides a number of new features and benefits:\\n\\n-   [New state management API](#new-state-management-api)\\n-   [Simplified element registration](#simplified-element-registration)\\n\x3c!-- Both UI (form re-renders) and element state --\x3e\\n-   [Improved UI consistency](#improved-ui-consistency)\\n\\n## New State Management API\\n\\nWe\'ve created a new state management API that improves custom form element development in a number of ways. Let\'s take a look in-depth at what\'s changed.\\n\\n### Improved `props` interface\\n\\nWe now provide an easy way to extend the props interface with additional public properties for your element. We\'ve also flattened the element\'s properties from `props.element` onto the root of the `props` object and have removed unused properties that were used internally in the product but didn\'t make sense for most custom form elements:\\n\\n```diff\\n- import { CustomFormElementProps } from \\"@geocortex/workflow/runtime/app/RegisterCustomFormElementBase\\";\\n+ import { FormElementProps } from \\"@geocortex/workflow/runtime\\";\\n\\n\\n// The generic type argument provided to `FormElementProps`\\n// allows you to specify the type of `value`.\\n// This will strongly type `props.value` and `props.setValue()`.\\n// You can now add additional properties to your element\'s\\n// props interface. Previously there wasn\'t a great pattern\\n// to declare additional properties for an element.\\n+ interface DemoElementProps extends FormElementProps<number> {\\n+    foo: string;\\n+ }\\n\\n\\n- function DemoElement(props: CustomFormElementProps) {\\n+ function DemoElement(props: DemoElementProps) {\\n    // Get the current `value`. Previously `value` wouldn\'t be\\n    // strongly typed. Here we\'ve typed as `number` as declared\\n    // in our interface above.\\n-   const currentValue = props.element.value;\\n+   const currentValue = props.value;\\n\\n\\n    // Get a custom `foo` property used by my element.\\n+   const currentFoo = props.foo;\\n\\n\\n    // ...\\n}\\n```\\n\\n### `setValue()` and `setProperty()`\\n\\nThese new APIs are included in the props interface and help to improve developer experience and ensure form consistency of both the UI presentation, but also the underlying element state.\\n\\nWe\'ve added the `setProperty()` API which is used to update properties of your element, such as additional public properties that you\'ve added to your element by extending the `FormElementProps` interface.\\n\\nWe\'ve also added `setValue()`. `setValue(value)` is equivalent to calling `setProperty(\\"value\\", value)`. Using the previous API, developers had to remember to raise the `changed` event when updating the `value` property on their element. This was necessary so that workflow authors could run sub-workflows on the `change` event of the element. This is no longer needed as the `setValue()` API will automatically raise the `changed` event for you.\\n\\nAdditionally, the previous patterns didn\'t guarantee that the form would re-render after updating the properties of your element and could result in some challenging UI and data consistency issues. By using the `setProperty()` and `setValue()` APIs, your form will automatically be re-rendered to ensure that the UI shows the most up-to-date state at all times.\\n\\n```diff\\n// Get the current `value`.\\n- const currentValue = props.element.value;\\n+ const currentValue = props.value;\\n\\n\\n// Update the element\'s value.\\n- props.element.value = value;\\n- props.raiseEvent(\\"changed\\", value);\\n+ props.setValue(value);\\n\\n\\n// Get a custom `foo` property used by my element.\\n- const currentFoo = (props.element as any).foo;\\n+ const currentFoo = props.foo;\\n\\n\\n// Set the element\'s `foo` property.\\n- (props.element as any).foo = foo;\\n+ props.setProperty(\\"foo\\", foo);\\n```\\n\\n## Simplified Element Registration\\n\\nTo register your custom form elements using the previous API, you would need to create a Workflow activity that registers your element:\\n\\n```ts\\nexport class RegisterDemoElement extends RegisterCustomFormElementBase {\\n    execute(): void {\\n        // Where `DemoElement` refers to a React component.\\n        this.register(\\"Demo\\", DemoElement);\\n    }\\n}\\n```\\n\\nThis added some extra boilerplate that we felt was unnecessary. More importantly it required the workflow author to run this element registration activity _prior_ to running the _Display Form_ activity that used the custom element. This was an awkward step that Workflow authors had to remember to do for their forms to render correctly.\\n\\nWhen registering your element using the new API and the latest version of the Workflow SDK, it is no longer necessary to run the activity prior to _Display Form_:\\n\\n```ts\\nconst DemoElementRegistration: FormElementRegistration<DemoElementProps> =\\n    {\\n        component: DemoElement,\\n        id: \\"Demo\\",\\n    };\\n\\nexport default DemoElementRegistration;\\n```\\n\\n## Improved UI Consistency\\n\\nThe new `setProperty()` and `setValue()` APIs make it much easier to develop Workflow elements using the common patterns developers are familiar with when building React components. Let\'s look at a simple example of a text input element built using the previous API:\\n\\n```tsx\\nfunction Text(props: CustomFormElementProps) {\\n    return (\\n        <input\\n            // When the text input changes, update the element\'s `value`.\\n            onChange={(event) =>\\n                (props.element.value = event.currentTarget.value)\\n            }\\n            // Show the element `value `in the text input.\\n            value={props.element.value}\\n        />\\n    );\\n}\\n```\\n\\nThere are a few gotchas here that are likely not obvious at first glance:\\n\\n1. We forgot to call `props.raiseEvent(\\"changed\\", value)`. If the workflow author tried to run a sub-workflow on the change event of your element, it would never run.\\n1. The re-rendering of the element wasn\'t deterministic previously. Even if we updated `props.element.value` _and_ invoked `props.raiseEvent(\\"changed\\", value)`, there was no guarantee that this element would re-render immediately. In that case the UI wouldn\'t show the updated value, and would be out-of-sync with the underlying state of the element.\\n1. `value` will be `undefined` during the initial render, until the `onChange` fires for the first time. There are ways to work around this such as running a sub-workflow on the `load` event to set the element\'s value, however this makes development awkward.\\n1. Other parts of the system could update the element\'s `value` to a type that the element doesn\'t expect. For example, instead of `value` being a `string` like we expect, the workflow author could accidentally set the value to an `object` using the _Set Form Element Property_ activity.\\n\\nIt was possible to overcome these gotchas, but it required additional logic that often wasn\'t immediately obvious. We\'ve had to overcome these same challenges when writing form elements within Workflow itself.\\n\\nSo how would we build this element using the new APIs and avoid the gotchas described above? Let\'s take a look:\\n\\n```tsx\\ninterface TextProps extends FormElementProps<string> {}\\n\\nfunction Text(props: TextProps) {\\n    return (\\n        <input\\n            // 1. `setValue()` automatically raises the `changed`\\n            // event for you.\\n            onChange={(event) =>\\n                props.setValue(event.currentTarget.value)\\n            }\\n            // 2. The component will be re-rendered immediately by\\n            // using `setValue()`, ensuring that your UI and element\\n            // state are consistent.\\n            value={props.value}\\n        />\\n    );\\n}\\n\\nconst TextElementRegistration: FormElementRegistration<TextProps> = {\\n    component: Text,\\n    id: \\"Text\\",\\n    // 3. We can provide a default value, avoiding the initial\\n    // `undefined` value.\\n    getInitialProperties: () => ({ value: \\"\\" }),\\n    // 4. We can ensure data consistency by sanitizing changes\\n    // to our element\'s properties.\\n    onPropertyChange: ({ properties, property }) => {\\n        if (property === \\"value\\") {\\n            const value = properties[property];\\n\\n            if (typeof value !== \\"string\\") {\\n                throw new Error(\\"Unexpected type\\");\\n            }\\n        }\\n    },\\n};\\n```\\n\\n## Summary\\n\\nSo what does all of this mean in practice? Below we\'ll compare elements built using the new and old APIs.\\n\\n### Simple Use Case\\n\\nHere\'s a simple text input element:\\n\\n#### Before\\n\\nFor the sake of brevity, we\'ve excluded the additional logic that would be needed to overcome the gotchas [described above](#improved-ui-consistency).\\n\\n```tsx\\nimport * as React from \\"react\\";\\nimport { CustomFormElementProps } from \\"@geocortex/workflow/runtime/app/RegisterCustomFormElementBase\\";\\n\\nclass Text extends React.Component<CustomFormElementProps> {\\n    render(props) {\\n        return (\\n            <input\\n                value={props.element.value}\\n                onChange={(event) => {\\n                    this.props.element.value = value;\\n                    this.props.raiseEvent(\\"changed\\", value);\\n                }}\\n            />\\n        );\\n    }\\n}\\n\\n/**\\n * @displayName Text\\n * @category Custom Activities\\n * @description Registers the text input element for use in Display Form.\\n */\\nexport class RegisterTextElement extends RegisterCustomFormElementBase {\\n    execute(): void {\\n        this.register(\\"Text\\", Text);\\n    }\\n}\\n```\\n\\n#### After\\n\\n```tsx\\nimport {\\n    FormElementProps,\\n    FormElementRegistration,\\n} from \\"@geocortex/workflow/runtime\\";\\n\\ninterface TextProps extends FormElementProps<string> {}\\n\\n/**\\n * @displayName Text\\n * @category Custom Activities\\n * @description Displays a text input element.\\n */\\nfunction Text(props: TextProps) {\\n    return (\\n        <input\\n            value={props.value}\\n            onChange={(event) =>\\n                props.setValue(event.currentTarget.value)\\n            }\\n        />\\n    );\\n}\\n\\nconst TextElementRegistration: FormElementRegistration<TextProps> = {\\n    component: Text,\\n    id: \\"Text\\",\\n    getInitialProperties: () => ({\\n        value: \\"Hello World\\",\\n    }),\\n};\\n```\\n\\nNotice that updating the `value` for the element has been simplified by using the `setValue()` API. We\'re also now able to provide a default `value` of `\\"Hello World\\"` using `getInitialProperties`.\\n\\n### Advanced Use Case\\n\\nHere\'s a more advanced element that displays a range slider with configurable min, max, and step settings:\\n\\n#### Before\\n\\n```tsx\\nimport * as React from \\"react\\";\\nimport {\\n    CustomFormElementProps,\\n    RegisterCustomFormElementBase,\\n} from \\"@geocortex/workflow/runtime/app/RegisterCustomFormElementBase\\";\\n\\nclass RangeSlider extends React.Component<CustomFormElementProps> {\\n    render() {\\n        const { element, raiseEvent } = this.props;\\n\\n        return (\\n            <div>\\n                <input\\n                    max={100}\\n                    min={0}\\n                    // Even though we\'re updating the element value, until\\n                    // the element is re-rendered the UI won\'t update.\\n                    onChange={(event) => {\\n                        const value =\\n                            event.currentTarget.valueAsNumber;\\n                        element.value = value;\\n                        raiseEvent(\\"changed\\", value);\\n                    }}\\n                    step={5}\\n                    type=\\"range\\"\\n                    // There\'s no way to guarantee that `value` is always a\\n                    // `number`. A workflow could set the `value` to an\\n                    // unexpected type such as by using the\\n                    // `Set Form Element Property` activity.\\n                    value={element.value as number}\\n                />\\n                {/* \\n                    The element wasn\'t guaranteed to re-render, \\n                    so this UI may not update immediately.\\n                    `element.value` will be `undefined` initially\\n                    until set the first time.\\n                */}\\n                <span>{element.value}</span>\\n            </div>\\n        );\\n    }\\n}\\n\\n/**\\n * @displayName Register RangeSlider Form Element\\n * @description Displays a number range slider.\\n * @param props The props that will be provided by the Workflow runtime.\\n */\\nexport class RegisterRangeSliderElement extends RegisterCustomFormElementBase {\\n    execute(): void {\\n        this.register(\\"RangeSlider\\", RangeSlider);\\n    }\\n}\\n```\\n\\n#### After\\n\\nHere\'s the same element but also including configurable `max`, `min`, and `step` properties.\\n\\n```tsx\\nimport * as React from \\"react\\";\\nimport {\\n    FormElementProps,\\n    FormElementRegistration,\\n} from \\"@geocortex/workflow/runtime\\";\\n\\ninterface RangeSliderProps extends FormElementProps<number> {\\n    max: number;\\n    min: number;\\n    step: number;\\n}\\n\\n/**\\n * @displayName Range Slider\\n * @description Displays a number range slider.\\n * @param props The props that will be provided by the Workflow runtime.\\n */\\nfunction RangeSlider(props: RangeSliderProps): React.ReactElement {\\n    const { max, min, setValue, step, value } = props;\\n    return (\\n        <div>\\n            <input\\n                max={max}\\n                min={min}\\n                onChange={(event) =>\\n                    setValue(event.currentTarget.valueAsNumber)\\n                }\\n                step={step}\\n                type=\\"range\\"\\n                value={value}\\n            />\\n            <span>{value}</span>\\n        </div>\\n    );\\n}\\n\\nconst RangeSliderElementRegistration: FormElementRegistration<RangeSliderProps> =\\n    {\\n        component: RangeSlider,\\n        getInitialProperties: () => ({\\n            max: 100,\\n            min: 0,\\n            step: 5,\\n            value: 50,\\n        }),\\n        id: \\"RangeSlider\\",\\n        onPropertyChange: ({ properties, property }) => {\\n            if (\\n                property === \\"max\\" ||\\n                property === \\"min\\" ||\\n                property === \\"step\\" ||\\n                property === \\"value\\"\\n            ) {\\n                const value = properties[property];\\n\\n                // Ensure we always have the type we expect assigned to the element\\n                // properties.\\n                if (\\n                    typeof value !== \\"number\\" ||\\n                    Number.isNaN(value)\\n                ) {\\n                    throw new Error(\\"Unexpected type\\");\\n                }\\n            }\\n        },\\n    };\\n\\nexport default RangeSliderElementRegistration;\\n```"}]}}')}}]);